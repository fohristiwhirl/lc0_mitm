"use strict";

// HTML stuff.......................................................
//
// All of this may be redundant since id-havers are in the global
// namespace automatically. But declaring them const has some value.

const boardfriends = document.getElementById("boardfriends");
const boardsquares = document.getElementById("boardsquares");
const canvas = document.getElementById("canvas");
const fantasy = document.getElementById("fantasy");
const fenbox = document.getElementById("fenbox");
const infobox = document.getElementById("infobox");
const movelist = document.getElementById("movelist");
const pgnchooser = document.getElementById("pgnchooser");
const promotiontable = document.getElementById("promotiontable");
const statusbox = document.getElementById("statusbox");

// Globals..........................................................

const context = canvas.getContext("2d");
const decoder = null;						// new TextDecoder("utf8");

let tree_version = 0;

let config = {

	"options": {},

	"board_size": 640,
	"info_font_size": 16,
	"pgn_font_size": 16,
	"fen_font_size": 16,
	"status_font_size": 16,
	"arrow_width": 8,
	"arrowhead_radius": 12,
	"board_font": "18px Arial",

	"light_square": "#dadada",
	"dark_square": "#b4b4b4",
	"active_square": "#66aaaa",
	"move_colour": "#ffff00",
	"move_colour_alpha": 0.15,
	"best_colour": "#66aaaa",
	"good_colour": "#66aa66",
	"bad_colour": "#cccc66",
	"terrible_colour": "#cc6666",
	"bad_move_threshold": 0.02,
	"terrible_move_threshold": 0.04,
	"uncertainty_cutoff": 0.1,
	"arrowhead_type": 0,
	"show_cp": false,
	"cp_white_pov": false,
	"show_n": false,
	"show_n_abs": true,
	"show_p": true,
	"show_v": false,
	"show_q": false,
	"show_d": false,
	"show_u": false,
	"show_q_plus_u": false,
	"searchmoves_buttons": true,
	"hover_draw": false,
	"hover_method": 0,
	"serious_analysis_mode": false,
	"sam_ev": true,
	"sam_n": true,
	"sam_n_abs": false,
	"sam_of_n": true,
	"sam_p": false,
	"sam_v": false,
	"sam_q": false,
	"sam_d": false,
	"sam_u": false,
	"sam_q_plus_u": false,
	"update_delay": 170,
	"animate_delay_multiplier": 4,
	"search_nodes": "infinite",
	"save_enabled": false,
	"override_piece_directory": null,
	"logfile": null,
	"log_info_lines": false
};

config.flip = false;
config.versus = "";
config.square_size = Math.floor(config.board_size / 8);
config.board_size = config.square_size * 8;

let debug = Object.create(null);

let images = Object.create(null);
images.P = new Image(); images.P.src = "data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI1MG1tIiBpbWFnZS1yZW5kZXJpbmc9Im9wdGltaXplUXVhbGl0eSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHRleHQtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHZpZXdCb3g9IjAgMCA1MCA1MCIgd2lkdGg9IjUwbW0iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC45NzMyNCAwIDEuMjQzKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyMS4xMyIgeDI9Ijc3Ljc2NCIgeTE9IjM3LjM0NiIgeTI9IjM3LjQ2OSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmIiBzdG9wLW9wYWNpdHk9IjAiLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGQ9Ik0yNSA0Ni40NDhIMTEuNjA2YTEzLjEzOSAxMy4xMzkgMCAwIDEtLjk5LTUuMDQzYzAtMi45NzUuODYzLTUuNjQ0IDIuNTk4LTguMDE4IDEuNzM2LTIuMzY1IDMuOTcxLTQuMDU0IDYuNjk3LTUuMDY3YTYuODI0IDYuODI0IDAgMCAxLTIuODYxLTIuMzk4Yy0uNzM3LTEuMDcxLTEuMS0yLjI4My0xLjEtMy42MzQgMC0xLjY5LjU3NS0zLjE1NiAxLjczNS00LjM5MiAxLjE1MS0xLjI0NCAyLjU3NC0xLjk2MSA0LjI2Ny0yLjE1LTEuMzQ2LS45ODEtMi4wMTUtMi4yODMtMi4wMTUtMy44OSAwLTEuMzUxLjQ5MS0yLjUxMyAxLjQ4Mi0zLjQ3Ny45ODItLjk2NCAyLjE3Ni0xLjQ0MiAzLjU4MS0xLjQ0MiAxLjM4OSAwIDIuNTgyLjQ3OCAzLjU3MyAxLjQ0Mi45OS45NjQgMS40OSAyLjEyNiAxLjQ5IDMuNDc3IDAgMS42MDctLjY2OSAyLjkwOS0yLjAxNSAzLjg5IDEuNjkzLjE4OSAzLjExNi45MDYgNC4yNjcgMi4xNSAxLjE2IDEuMjM2IDEuNzM2IDIuNzAzIDEuNzM2IDQuMzkyIDAgMS4zNTEtLjM3MyAyLjU2My0xLjEyNiAzLjYzNGE3LjAzNiA3LjAzNiAwIDAgMS0yLjg2MiAyLjM5OGMyLjcyNiAxLjAxMyA0Ljk2MiAyLjcwMiA2LjY5NyA1LjA2NyAxLjczNiAyLjM3NCAyLjYgNS4wNDMgMi42IDguMDE4IDAgMS43MzktLjMyMiAzLjQyLS45NjYgNS4wNDN6IiBmaWxsPSIjMWYxYTE3Ii8+PHBhdGggZD0iTTI1IDQ0LjgwOGgxMi4xNzVhMTEuNzkgMTEuNzkgMCAwIDAgLjUyNS0zLjQwM2MwLTIuNTEzLS43MTEtNC43ODctMi4xNDItNi44MzEtMS40My0yLjA0NC0zLjI3Ny0zLjU1Mi01LjUyLTQuNTE2LTEuNTg0LS42Mi0xLjY0My0uNjU5LTEuNjQzLTEuNzM4IDAtLjg0OS41NTktMS40NzUgMS42NjgtMS44NzkgMS41MzMtMS4wNDYgMi4zMDMtMi40MyAyLjMwMy00LjE1MyAwLTEuMjQ0LS40MzItMi4zMjQtMS4yODctMy4yNjMtLjg2NC0uOTMxLTEuOTA1LTEuNDY3LTMuMTI0LTEuNjE1LTEtLjA4My0xLjQ5LS42MjYtMS40OS0xLjY0IDAtLjQ1My4xNzgtLjg3My41NDItMS4yNi44OTctLjY3NiAxLjM0Ni0xLjU1OCAxLjM0Ni0yLjY1NCAwLS44OTgtLjMzOS0xLjY3My0xLTIuMzE1LS42Ni0uNjQzLTEuNDQ3LS45NjQtMi4zNTMtLjk2NC0uOTQgMC0xLjc0NC4zMi0yLjM5Ni45NjRhMy4xMzYgMy4xMzYgMCAwIDAtLjk3NCAyLjMxNWMwIDEuMDguNDQgMS45NjEgMS4zMzggMi42NTMuMzY0LjM1NS41NDIuNzc1LjU0MiAxLjI2MSAwIDEuMDE0LS40ODMgMS41NTctMS40NjUgMS42NGE0LjkgNC45IDAgMCAwLTMuMTMzIDEuNjE1Yy0uODU1Ljk0LTEuMjc4IDIuMDE5LTEuMjc4IDMuMjYzIDAgMS43MjIuNzcgMy4xMDcgMi4zMDMgNC4xNTMgMS4xMS40MTIgMS42NjggMS4wNDYgMS42NjggMS44NzkgMCAxLjA4LS4wNjggMS4xMTgtMS42NjggMS43MzgtMi4yNDQuOTY0LTQuMDgxIDIuNDcyLTUuNTAzIDQuNTE2LTEuNDIzIDIuMDQ0LTIuMTM0IDQuMzE4LTIuMTM0IDYuODMxIDAgMS4xOTUuMTc4IDIuMzI0LjUyNSAzLjQwM3oiIGZpbGw9InVybCgjYSkiLz48L3N2Zz4=";
images.N = new Image(); images.N.src = "data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI1MG1tIiBpbWFnZS1yZW5kZXJpbmc9Im9wdGltaXplUXVhbGl0eSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHRleHQtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHZpZXdCb3g9IjAgMCA1MCA1MCIgd2lkdGg9IjUwbW0iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIxLjQwNSIgeDI9Ijc3LjY0MSIgeTE9IjM3LjM0NiIgeTI9IjM3LjM0NiI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmIiBzdG9wLW9wYWNpdHk9IjAiLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGQ9Ik0yNi4xNzggOS4zOTVjMi42LjE3IDUuMDA0LjgzOCA3LjIyMiAyLjAxNSAyLjIxIDEuMTY5IDQuMDk4IDIuNjc2IDUuNjU2IDQuNTEzIDEuMDkyIDEuMjg3IDIuMTE3IDIuODQ1IDMuMDgyIDQuNjY1YTI4LjY4NCAyOC42ODQgMCAwIDEgMi4zMiA1Ljc3NCAzNi41MTEgMzYuNTExIDAgMCAxIDEuMjUzIDcuNDZjLjE3NyAyLjU5OS4yNjIgNS4wMTIuMjYyIDcuMjN2NS40MDJIMTUuNDY4Yy0uMTUzIDAtLjIyLS40MDctLjIxMi0xLjIxLjAwOS0uODE0LjA2LTEuNDY2LjE2LTEuOTY1LjA2LS4zOTguMjIxLS45NTcuNDY3LTEuNjg1LjI1NC0uNzI4LjY2LTEuNjA5IDEuMjQ0LTIuNjUuMjYzLS41MzQuODktMS4zMDQgMS44OC0yLjMyLjk5OS0xLjAxNiAyLjEzMy0yLjIwMSAzLjQyOS0zLjUzOS43NDUtLjc2MiAxLjMyLTEuNzE5IDEuNzQ0LTIuODc5LjQyMy0xLjE1MS42MDEtMi4yMDEuNTMzLTMuMTVhOC4zNyA4LjM3IDAgMCAxLTIuMDA2IDEuMjJjLTMuNTA1IDEuMjUzLTYuMDQ1IDMuMDczLTcuNjEyIDUuNDUyLS4xMTguMTUzLS40OS44MjItMS4xMTcgMi4wMTUtLjMzLjYyNy0uNjE4IDEuMDU5LS44NDcgMS4yODctLjMxMy4zMTQtLjc3LjQ5MS0xLjM2My41MjUtLjkyMy4wNDMtMS42NDMtLjM5OC0yLjE2LTEuMzQ2LS42OTMuMjAzLTEuMzEyLjI4OC0xLjg2Mi4yNTQtLjkyMy0uMzQ3LTEuNTkyLS43Mi0yLjAwNi0xLjExNy0uODQ3LS44NDctMS4zODktMS42ODUtMS42NTEtMi41MzJhOS40MyA5LjQzIDAgMCAxLS4zODEtMi43MjZjMC0xLjM4OS44NTUtMy4yMjYgMi41ODItNS41MTIgMi4wMTUtMi42MjUgMy4wOS00LjYzMSAzLjIxNy02LjAwMyAwLS41OTMuMDYtMS4yNjEuMTc4LTIuMDA3YTQuMTk4IDQuMTk4IDAgMCAxIC42MTgtMS40OWMuMjItLjMzLjM2NC0uNTU4LjQzMi0uNjc3LjA3Ni0uMTI3LjIxMi0uMzEzLjQxNS0uNTU5LjE0NC0uMjAzLjI3LS4zNTUuMzcyLS40NTcuMDkzLS4xMS4yMi0uMjU0LjM3My0uNDQuMTc4LS4yMTIuNDA2LS40NTcuNjk0LS43NDVhMTguMDYgMTguMDYgMCAwIDEtMS4wNjctNy40NmMzLjI4NSAxLjE2OSA2LjA1NCAzLjAxNSA4LjI4IDUuNTMuNTUxLTEuODcyIDEuNjI2LTMuMzg3IDMuMjI2LTQuNTM5IDEuMzIxLjkyMyAyLjM3MSAyLjE1IDMuMTUgMy42NjZ6IiBmaWxsPSIjMWYxYTE3Ii8+PHBhdGggZD0iTTQyLjk3NiA0NC42OTNjLS4wMTcgMCAwLS40NDkuMDQyLTEuMzQ2LjA1MS0uOTA2LjA3Ni0xLjg4LjA3Ni0yLjkyMS4wMTctMi4wNjYuMDE3LTQuMiAwLTYuNDFhMjYuODM3IDI2LjgzNyAwIDAgMC0uODg5LTYuNjEyYy0uNTY3LTIuMTE3LTEuMTg1LTMuOTItMS44NjItNS40MTktLjY3OC0xLjQ5OC0xLjQxNC0yLjc4NS0yLjIxLTMuODc4LTEuMTg1LTEuNzg2LTIuODExLTMuMzAyLTQuODYtNC41MzgtMi4wNDktMS4yNDQtNC4xOS0yLjA1Ny02LjQyNi0yLjQzOC4xNTIuODEzLjIyIDEuNjA5LjIwMyAyLjM4Ny0uMDM0LjU5My0uMzEzLjg5LS44NDcuODktLjYxIDAtLjg4LS4yOTctLjgyLS44OS4wNS0yLjE4NC0uNzI5LTQuMDU1LTIuMzMtNS42MDQtMS4yNTIgMS4zMi0xLjkzOCAyLjg1My0yLjAzMSA0LjYwNS0uMDM0LjU4NS0uMzMuODM5LS44OTguNzctLjUyNS0uMDE2LS43ODctLjMyLS43ODctLjkxNCAwIDAgLjAxNy0uMDY3LjA0Mi0uMjAzLS42NzcuMjItMS4zODguNTI1LTIuMTMzLjkyMy0uNDc0LjMzLS44NjQuMjQ2LTEuMTYtLjI0NS0uMjk3LS41LS4xNy0uODkuMzk4LTEuMTY5LjcxLS4zNjQgMS4yNDQtLjYzNSAxLjYwOC0uODIxYTE3LjYzNCAxNy42MzQgMCAwIDAtNC44Ni0zLjUyMiAxNy4zMSAxNy4zMSAwIDAgMCAxLjg4OSA2LjUyOGMuMjc5LjQyMy4yMTEuODA0LS4yMDQgMS4xMzQtLjQ2NS4zNjQtLjg1NS4zMTMtMS4xNjgtLjE3YTguODcgOC44NyAwIDAgMS0uNDkxLS44OTdjLS4zNDcuMzQ3LS41ODQuNjEtLjY5NC43Ny0uMTE5LjE1My0uMzIyLjQ4My0uNjEuOTkxLS4yODguNTE3LS41Ljk0LS42MzUgMS4yNy0uMTQ0LjQxNS0uMjEyLjc0NS0uMTg2IDEuMDA4LjAyNS4yNTQuMDUuNTMzLjA2Ny44NTVhNy42MSA3LjYxIDAgMCAxLTEuMDA3IDIuNzUyIDEzMy43MSAxMzMuNzEgMCAwIDEtMS45OTggMy4xNSAxMjcuNjA3IDEyNy42MDcgMCAwIDEtMS43ODcgMi42NzVjLS40MTUuNjAxLS43MjggMS4zNTQtLjk0IDIuMjg2LS4xNTIuNTU5LS4xNTIgMS4yNDQgMCAyLjA0LjE0NC44MDUuNDc1IDEuNDMxLjk2NiAxLjg4Ljc2Mi43NyAxLjQ5OCAxLjEyNiAyLjIxIDEuMDY3LjIyOCAwIC41NDEtLjA5My45My0uMjguMzktLjE3OC42ODctLjUyNS45MDctMS4wNDEuNDIzLS45NC43NzktMS40MTQgMS4wNjctMS40MTQuNDA2IDAgLjYzNS4yMzcuNjY4LjY5NCAwIC4xMDItLjEzNS41MTctLjM5NyAxLjI0NS0uMTUzLjMzLS4zNDguNjc3LS41OTMgMS4wNDEtLjMyMi40MzItLjQ1Ny42MS0uNDIzLjU0Mi4yNjIuOTQ4LjcwMiAxLjExIDEuMzEyLjUuMTc4LS4xNzguMzktLjUyNS42MTgtMS4wMTYuMjM3LS41LjYwMS0xLjE2OSAxLjA5Mi0yLjAwNy41ODQtLjk4MiAxLjIwMi0xLjc3IDEuODYzLTIuMzg4LjY2LS42MSAxLjI0NC0xLjEwOSAxLjc2LTEuNDgxLjI5Ny0uMjIuNjYxLS40NjYgMS4wOTMtLjc0NS40MzItLjI4OCAxLjAwOC0uNTc2IDEuNzM2LS44NzIuNTc2LS4yMjkgMS4yMTktLjUxNyAxLjkyMi0uODU2czEuMzI5LS43NyAxLjg3LTEuMzAzYy43NjMtLjc0NSAxLjM0Ny0xLjY2IDEuNzYyLTIuNzUyLjIyLS42MS4yOTYtMS4zNjMuMjQ1LTIuMjYtLjE0NC0uNTYuMTM2LS44MzkuODQ3LS44MzkuNTMzIDAgLjgzLjI3MS44OTguODIxIDAgMS44NjMtLjUzNCAzLjU2NS0xLjU5MiA1LjEwNi4zNDcgMS4wNTguNDQgMi4yMTguMjcgMy40NzEtLjE0MyAxLjAwOC0uNDk5IDIuMDkxLTEuMDUgMy4yNDMtLjU1OCAxLjE0My0xLjY3NiAyLjQyMS0zLjM2IDMuODI3LTMuNDMgMi44NDUtNS4wNDYgNS43NzQtNC44NiA4Ljc4aDEyLjE3NXpNOS4zMzggMjkuNjEzYy0uNDgzLjI5Ny0uNzcuNjk1LS44NzIgMS4xOTQuMDE3LjU0Mi0uMjM3LjgzOS0uNzYyLjg5LS41ODQuMDY3LS44OC0uMTc4LS44OTgtLjc0Ni4wNjgtMS4wOTIuNTUtMS45NTUgMS40NjUtMi41OTkuNDMyLS4zNDcuODMtLjMyMiAxLjE5NC4wOTMuMzY0LjQ0OS4zMjIuODM4LS4xMjcgMS4xNjl6bTcuMzY2LTExLjgyN2MuMjEyLjMzLjI5Ni42NzcuMjQ1IDEuMDQxLS4xNiAxLjA1OC0uNzUzIDEuNDk5LTEuNzYgMS4zMzhhMS41OTYgMS41OTYgMCAwIDEtLjcyLS4yOTZjLS4wNi4wNzYtLjE2MS4yNjItLjI5Ny41NDEtLjE3OC41MzQtLjUyNS43MTItMS4wNDEuNTUtLjUwOC0uMjAyLS43MTEtLjU3NS0uNTkzLTEuMTE3Ljc0NS0xLjkwNSAyLjA5MS0zLjIwOSA0LjAzOS0zLjkyLjU2Ny0uMTcuOTQgMCAxLjExNy40OTEuMjA0LjUzNC4wNTEuODk4LS40NDggMS4wOTJhMi43NDUgMi43NDUgMCAwIDEtLjI3MS4xMzZjLS4wODUuMDQyLS4xNy4wOTMtLjI3MS4xNDR6IiBmaWxsPSJ1cmwoI2EpIi8+PC9zdmc+";
images.B = new Image(); images.B.src = "data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI1MG1tIiBpbWFnZS1yZW5kZXJpbmc9Im9wdGltaXplUXVhbGl0eSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHRleHQtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHZpZXdCb3g9IjAgMCA1MCA1MCIgd2lkdGg9IjUwbW0iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIxLjEzIiB4Mj0iNzcuNjQxIiB5MT0iMzcuNTkyIiB5Mj0iMzcuNDY5Ij48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmYiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmZmYiIHN0b3Atb3BhY2l0eT0iMCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggZD0iTTI1LjQ0NyA0Mi4wMDhjLS4yMjguOTQtLjUxNiAxLjU5Mi0uODQ2IDEuOTU2LS4zMy4zNjQtLjc2Mi43NDUtMS4zMTMgMS4xNDMtLjU5Mi40MTUtMS4yOTUuNzYyLTIuMTA4IDEuMDUtLjgxMy4yODgtMS43MS4zNjQtMi43LjIxMWwtNi45NjktLjk2NWEyLjg1OCAyLjg1OCAwIDAgMC0uNzYyIDBjLS4yMi4wMzQtLjQzMi4wNTEtLjYzNS4wNTEtLjM0NyAwLS43ODcuMDc2LTEuMzIuMjM3LS41NDIuMTUyLS45NTcuMzgxLTEuMjU0LjY3N2wtMi40MDQtMy45NDVjLjI5Ni0uMzMuNTU5LS41NTkuNzg3LS42OTQuMjM3LS4xMjcuNTA4LS4yNzEuODIxLS40MTVhOS4xNzkgOS4xNzkgMCAwIDEgMy4wNzQtLjgyMmMuNDY2LS4wMzMuOTIzLS4wNDIgMS4zNjMtLjAyNWE5LjggOS44IDAgMCAwIDEuMzk3LS4wNWMuODkuMTUyIDEuNzg2LjI4NyAyLjY4NC40MDYuOTA2LjEyNyAxLjgxMi4yNTQgMi43MTguMzkuOTkgMCAxLjY2LS4xMDIgMi4wMDYtLjI5Ny4xODctLjEwMi40NzQtLjI4OC44NzItLjU1LjM5OC0uMjYzLjc5Ni0uNjUyIDEuMTk0LTEuMTY5LS44OC0uMDkzLTEuNzctLjI2Mi0yLjY4NC0uNTA4YTI0LjA5NCAyNC4wOTQgMCAwIDEtMi40MDQtLjc1M2wyLjU4Mi02LjQwMWMtMS4yOTUtLjc0NS0yLjE5My0xLjMzOC0yLjcxLTEuNzk1YTUuMyA1LjMgMCAwIDEtMS4yMS0xLjU3NWMtLjQzMi0uNzYyLS43MTEtMS40OTktLjgzLTIuMjFhOS4zNDEgOS4zNDEgMCAwIDEtLjE2LTEuOTEzYy4wMTYtLjk5LjI0NS0yLjA4My43MDItMy4yODUuNDU3LTEuMTk0IDEuMzEyLTIuMjcgMi41NjYtMy4yMWE3OS4wOTEgNzkuMDkxIDAgMCAwIDMuMDU2LTIuNDU1IDI3Ljc0NiAyNy43NDYgMCAwIDAgMi45NDYtMi45NTRjLTEuMjE5LS42MjctMS44MjgtMS42MjYtMS44MjgtMi45OTggMC0uOTMuMzIxLTEuNzE4Ljk3My0yLjM4Ny42NTItLjY2IDEuNDU3LS45OSAyLjM5Ni0uOTkuOTIzIDAgMS43Mi4zMyAyLjM4Ljk5LjY2LjY2OS45OSAxLjQ1Ni45OSAyLjM4NyAwIDEuMzU1LS42MSAyLjM1NC0xLjgyOSAyLjk5OGEyNi43OTYgMjYuNzk2IDAgMCAwIDIuOTEzIDIuOTU0Yy45ODIuODM5IDIuMDE1IDEuNjYgMy4wOSAyLjQ1NiAxLjIzNi45NCAyLjA4MyAyLjAxNSAyLjUyMyAzLjIwOS40NDkgMS4yMDIuNjk0IDIuMjk0LjcyIDMuMjg1IDAgLjU2Ny0uMDUgMS4yMDItLjE3IDEuOTEzcy0uMzggMS40NDgtLjc5NSAyLjIxYTYuMDg0IDYuMDg0IDAgMCAxLTEuMjUzIDEuNTc1Yy0uNS40NTctMS4zODkgMS4wNS0yLjY2NyAxLjc5NWwyLjU4MiA2LjRhMjguNTcgMjguNTcgMCAwIDEtMi40NTUuNzU0Yy0uOTE1LjI0Ni0xLjc4Ny40MTUtMi42MzQuNTA4LjM4MS41MTcuNzcxLjkwNiAxLjE2OSAxLjE2OC4zOTguMjYzLjY5NC40NS44OTcuNTUuMzQ3LjE5NiAxLjAxNi4yOTcgMi4wMDcuMjk3YTI2My4zNSAyNjMuMzUgMCAwIDEgMi42OTItLjM5IDgxLjEzIDgxLjEzIDAgMCAwIDIuNzE4LS40MDZjLjQ0LjA1MS44OS4wNjggMS4zNDYuMDUxYTEzLjEyIDEzLjEyIDAgMCAxIDEuNDA2LjAyNSA5LjYyNyA5LjYyNyAwIDAgMSAzLjA3My44MjJjLjI5Ny4xNDQuNTY3LjI4OC44MDUuNDE1LjI0NS4xMzUuNTA4LjM2NC44MDQuNjk0bC0yLjQzIDMuOTQ1Yy0uMjk2LS4yOTYtLjcxMS0uNTI1LTEuMjUzLS42NzctLjUzNC0uMTYtLjk2NS0uMjM3LTEuMjk2LS4yMzctLjIyIDAtLjQ0LS4wMTctLjY2LS4wNWEyLjc5NCAyLjc5NCAwIDAgMC0uNzUzIDBsLTYuOTUyLjk2NGMtLjk5LjE1My0xLjkxMy4wODUtMi43Ni0uMTk0LS44NTUtLjI4LTEuNTU4LS42NTItMi4xLTEuMTE4YTIwLjA0IDIwLjA0IDAgMCAxLTEuMzAzLTEuMTUxYy0uMzIyLS4zMjItLjU5My0uOTU3LS44MDUtMS44OTd6IiBmaWxsPSIjMWYxYTE3Ii8+PHBhdGggZD0iTTI2LjMyIDM5LjE5N2MwIDEuMDkyLjI0NSAyLjAyNC43NTMgMi43OTQuNS43NyAxLjA0MSAxLjM3MiAxLjYyNiAxLjc5NS45MDUuNjY5IDIuMjM1IDEgMy45ODcgMSAuNDMyIDAgMS4yNzktLjA5NCAyLjUzMi0uMjhhNzQuNzM3IDc0LjczNyAwIDAgMSAyLjQ4LS4zNTZjLjYyNy0uMDc2IDEuMDUtLjEzNSAxLjI3LS4xODZhNi41MyA2LjUzIDAgMCAxIDEuOTgyLjA1Yy4yNjIuMDY4LjU1OS4xMjguODguMTg3YTEuNiAxLjYgMCAwIDEgLjgwNS4zOGwxLjE5NC0xLjkzYTcuMzcyIDcuMzcyIDAgMCAwLTIuMTYtLjcyYy0xLjI1Mi0uMjItMi4zNTMtLjI2Mi0zLjMwMS0uMTUxLS4yOC4wMzMtLjY0NC4xMTgtMS4xMDEuMjQ1LS40NTcuMTM2LTEuMDY3LjI2My0xLjg0Ni4zNzItMS42NzYuMjcyLTIuNTU3LjM5OS0yLjY1OC4zOTktLjY0NCAwLTEuMjAzLS4wNzctMS42ODUtLjI0NmExMC4zNyAxMC4zNyAwIDAgMS0xLjI4Ny0uNTQyYy0uODgtLjM5OC0xLjc3LTEuMzM4LTIuNjg0LTIuODF6bS0xLjc2MiAwaC0uNzk1Yy0uOTMyIDEuNDktMS44MTIgMi40My0yLjY1OSAyLjgxMS0uMzk4LjE5NS0uODMuMzczLTEuMzEyLjU0Mi0uNDgzLjE3LTEuMDMzLjI0Ni0xLjY2LjI0Ni0uMTE4IDAtLjk5OS0uMTI3LTIuNjU4LS4zOTgtLjc4OC0uMTEtMS40MjMtLjIzOC0xLjg4LS4zNzNhOC44MjggOC44MjggMCAwIDAtMS4wOTItLjI0NWMtLjk0OC0uMTEtMi4wNC0uMDY4LTMuMzAyLjE1MmE3LjA1NiA3LjA1NiAwIDAgMC0yLjEzNC43MmwxLjE5NCAxLjkzYy4xOTUtLjE5NS40NTctLjMyMi43NzktLjM4MS4zMjItLjA2LjYxOC0uMTE5Ljg4LS4xODZhNi41MyA2LjUzIDAgMCAxIDEuOTgyLS4wNTFjLjIyLjA1LjY0My4xMSAxLjI3LjE4Ni42MjYuMDc2IDEuNDY1LjE5NSAyLjUwNi4zNTYgMS4yMzYuMTg2IDIuMDgzLjI4IDIuNTMxLjI4IDEuNzM2IDAgMy4wNjUtLjMzMSAzLjk4OC0xIC41NjctLjQyMyAxLjEtMS4wMjQgMS42LTEuNzk1LjUwOC0uNzcuNzYyLTEuNzAyLjc2Mi0yLjc5NHptLjg5LTkuMzQ3YzEuNiAwIDMuMTQuMTI3IDQuNjE0LjM3MiAxLjYxNy0uNTc1IDIuNzk0LTEuNDgxIDMuNTIyLTIuN2E2Ljc0NSA2Ljc0NSAwIDAgMCAuOTQtMy40OTdjMC0uNzYyLS4xODctMS42LS41NjgtMi41MjMtLjM4LS45MTUtLjk5OS0xLjc0NC0xLjg2Mi0yLjQ5LS45NzQtLjgxMi0yLjA0LTEuNzAxLTMuMi0yLjY2NmEzMy4wOTMgMzMuMDkzIDAgMCAxLTMuNDQ3LTMuMzg3Yy0xLjE2IDEuMjg3LTIuMzExIDIuNDIxLTMuNDcgMy4zODdhNDA2LjU1IDQwNi41NSAwIDAgMC0zLjE3NiAyLjY2N2MtLjg4Ljc0NS0xLjQ5OSAxLjU3NC0xLjg3MSAyLjQ4OS0uMzczLjkyMy0uNTU5IDEuNzYtLjU1OSAyLjUyMyAwIDEuMjcuMzA1IDIuNDM4LjkxNCAzLjQ5Ny43MTIgMS4yMTkgMS44OTcgMi4xMjUgMy41NDggMi43YTI3Ljc0OSAyNy43NDkgMCAwIDEgNC42MTQtLjM3MnptMCA0LjUxM2MxLjkzOCAwIDMuNzkzLjE5NCA1LjU3OS41NzVsLTEuMTg1LTMuMDU2YTI4LjI5NyAyOC4yOTcgMCAwIDAtNC4zOTUtLjM0N2MtMS41MDcgMC0yLjk4LjExOC00LjQxLjM0N2wtMS4xOTQgMy4wNTZjMS43NjktLjM4IDMuNjQtLjU3NSA1LjYwNC0uNTc1em0wLTIzLjUzOGMxLjEyNiAwIDEuNjg0LS41NTkgMS42ODQtMS42ODVzLS41NTktMS42OTMtMS42ODUtMS42OTMtMS42ODQuNTY3LTEuNjg0IDEuNjkzYzAgMS4xMjYuNTU4IDEuNjg1IDEuNjg0IDEuNjg1em0wIDI3LjAwOWExOC45NyAxOC45NyAwIDAgMCAzLjI4NS0uMjhjMS4wNjYtLjE5NCAyLjEtLjQyMyAzLjA5LS42ODUtMS45NC0uNTA4LTQuMDY0LS43Ny02LjM3Ni0uNzctMi4zNDUgMC00LjQ3LjI2Mi02LjM3NS43Ny45NTcuMjYyIDEuOTczLjQ5IDMuMDQ4LjY4NmExOS40NiAxOS40NiAwIDAgMCAzLjMyNy4yNzl6bS0uODktMTQuMzM0bC0yLjA2NS0uMDI2Yy0uNTYgMC0uODM5LS4yNzktLjgzOS0uODQ2IDAtLjU1OS4yOC0uODM4LjgzOS0uODM4aDIuMDY1di0yLjEzNGMwLS41NzYuMjk3LS44NzIuODktLjg3Mi41NzUgMCAuODcyLjI5Ni44NzIuODcydjIuMTM0aDIuMTMzYy41NDIgMCAuODEzLjI4LjgxMy44MzggMCAuNTY3LS4yNzEuODQ2LS44MTMuODQ2SDI2LjMydjIuMDMyYzAgLjYwMi0uMjk3Ljg5OC0uODczLjg5OC0uNTkyIDAtLjg4OS0uMjk2LS44ODktLjg5OHoiIGZpbGw9InVybCgjYSkiLz48L3N2Zz4=";
images.R = new Image(); images.R.src = "data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI1MG1tIiBpbWFnZS1yZW5kZXJpbmc9Im9wdGltaXplUXVhbGl0eSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHRleHQtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHZpZXdCb3g9IjAgMCA1MCA1MCIgd2lkdGg9IjUwbW0iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIxLjM3NiIgeDI9Ijc3LjY0MSIgeTE9IjM3LjQ2OSIgeTI9IjM3LjQ2OSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmIiBzdG9wLW9wYWNpdHk9IjAiLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGQ9Ik0yOC40MDggOS4yMmg0LjIxNlY1LjgyNWg2Ljc5OXY5LjI5NmwtNS41MDMgNC4yNDJ2MTEuODYybDQuMjE2IDQuMjE2djUuMDhoMy43OTN2NS45MjdIOC4wNzFWNDAuNTJoMy43OTN2LTUuMDhsNC4yNDItNC4yMTZWMTkuMzYzbC01LjUwNC00LjI0MlY1LjgyNWg2Ljc3NFY5LjIyaDQuMjQyVjUuODI1aDYuNzl6IiBmaWxsPSIjMWYxYTE3Ii8+PHBhdGggZD0iTTMzLjA3MyAxNy42NzhsMy4xNS0yLjU1N2gtMjIuNDJsMy4xNzUgMi41NTd6bTcuMTk3IDI0LjUyOEg5Ljc1NnYyLjU1N0g0MC4yN3ptLTMuODQ0LTUuMDU1SDEzLjZ2My4zN2gyMi44MjZ6bS00LjIxNy0xNy43ODhIMTcuODE2djExLjg2MmgxNC4zOTN6bTUuNTA0LTUuOTI3VjcuNTFoLTMuMzk1djMuMzk1aC03LjY0NlY3LjUxaC0zLjM0NHYzLjM5NWgtNy42MlY3LjUxaC0zLjM5NXY1LjkyNnptLTEuOTE0IDIyLjAwNWwtMi41NDgtMi41MzFIMTYuOGwtMi42IDIuNTMxeiIgZmlsbD0idXJsKCNhKSIvPjwvc3ZnPg==";
images.Q = new Image(); images.Q.src = "data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI1MG1tIiBpbWFnZS1yZW5kZXJpbmc9Im9wdGltaXplUXVhbGl0eSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHRleHQtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHZpZXdCb3g9IjAgMCA1MCA1MCIgd2lkdGg9IjUwbW0iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIxLjI1MyIgeDI9Ijc3LjY0MSIgeTE9IjM3LjIyNCIgeTI9IjM3LjM0NiI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmIiBzdG9wLW9wYWNpdHk9IjAiLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGQ9Ik00NC41NDEgMTQuNzIzYy0uOTQgMC0xLjc0NC0uMzMtMi40MDQtLjk4Mi0uNjYtLjY1Mi0uOTkxLTEuNDQ4LS45OTEtMi4zOTYgMC0uOTIzLjMzLTEuNzE5Ljk5LTIuMzg4LjY2LS42NzcgMS40NjUtMS4wMDcgMi40MDUtMS4wMDcuOTMxIDAgMS43MjcuMzMgMi4zODggMS4wMDcuNjYuNjcuOTkgMS40NjUuOTkgMi4zODggMCAuOTQ4LS4zMyAxLjc0NC0uOTkgMi4zOTZhMy4yOCAzLjI4IDAgMCAxLTIuMzg4Ljk4MnptLTQuMzEgMjkuMjE5Yy0uODEyLjcxLTIuNjMzIDEuMzA0LTUuNDYgMS43ODYtMi44MjguNDc0LTYuMDg4LjcyLTkuNzcxLjcyLTMuNzUgMC03LjA1My0uMjU0LTkuODk4LS43NDUtMi44NDQtLjUtNC42NC0xLjExOC01LjM4NC0xLjg2M2wxLjU2Ni01Ljk1Mi0uNjk0LTMuODk1TDguNDA1IDMwLjIgNi4yOTcgMTQuNzc0bDEuMjEtLjQ3NCA2LjggMTEuNDU1LjE1Mi0xMy42NCAxLjY4NS0uMjk2IDUuMTgyIDEzLjcxNiAyLjc3Ni0xNC43NTdoMS43MmwyLjc3NiAxNC43MDZMMzMuNzMgMTEuODJsMS43MS4yOTYuMTUzIDEzLjY0IDYuODI0LTExLjQ4IDEuMTYuNTQxLTIuMDU4IDE1LjM1OS0yLjIxIDMuNzkzLS42OTQgMy45NDV6TTE0LjUzNSAxMS45ODhjLS45NDggMC0xLjc1Mi0uMzIxLTIuNDEzLS45NzMtLjY2LS42NTItLjk5LTEuNDU2LS45OS0yLjM5NiAwLS45MjMuMzMtMS43MTkuOTktMi4zOHMxLjQ2NS0uOTkgMi40MTMtLjk5Yy45MjMgMCAxLjcxOS4zMyAyLjM4Ljk5cy45OSAxLjQ1Ny45OSAyLjM4YzAgLjk0LS4zMyAxLjc0NC0uOTkgMi4zOTZhMy4yNjYgMy4yNjYgMCAwIDEtMi4zOC45NzN6TTUuNCAxNC43MjNjLS45NCAwLTEuNzM2LS4zMy0yLjM4OC0uOTgyLS42NTItLjY1Mi0uOTgyLTEuNDQ4LS45ODItMi4zOTYgMC0uOTIzLjMzLTEuNzE5Ljk4Mi0yLjM4OEMzLjY2NCA4LjI4IDQuNDYgNy45NSA1LjQgNy45NWMuOTQ4IDAgMS43NDQuMzMgMi40MTMgMS4wMDcuNjYuNjcuOTkgMS40NjUuOTkgMi4zODggMCAuOTQ4LS4zMyAxLjc0NC0uOTkgMi4zOTZhMy4zMjMgMy4zMjMgMCAwIDEtMi40MTMuOTgyem0xOS41NS0zLjk3Yy0uOTQgMC0xLjc0NS0uMzMtMi4zOTctLjk5MS0uNjUyLS42Ni0uOTc0LTEuNDY1LS45NzQtMi40MDUgMC0uOTMxLjMyMi0xLjcyNy45NzQtMi4zODcuNjUyLS42NiAxLjQ1Ni0uOTkgMi4zOTYtLjk5LjkyMyAwIDEuNzI3LjMzIDIuMzk2Ljk5YTMuMjMgMy4yMyAwIDAgMSAxIDIuMzg3YzAgLjk0LS4zMyAxLjc0NC0xIDIuNDA1LS42NjkuNjYtMS40NzMuOTktMi4zOTYuOTl6bTEwLjQxMyAxLjIzNWMtLjk0IDAtMS43MzYtLjMyMS0yLjM4Ny0uOTczLS42NTItLjY1Mi0uOTgzLTEuNDU2LS45ODMtMi4zOTYgMC0uOTIzLjMzLTEuNzE5Ljk4My0yLjM4czEuNDQ3LS45OSAyLjM4Ny0uOTljLjk0OCAwIDEuNzUzLjMzIDIuNDEzLjk5cy45OSAxLjQ1Ny45OSAyLjM4YzAgLjk0LS4zMyAxLjc0NC0uOTkgMi4zOTYtLjY2LjY1Mi0xLjQ2NS45NzMtMi40MTMuOTczeiIgZmlsbD0iIzFmMWExNyIgc3Ryb2tlPSIjMWYxYTE3IiBzdHJva2Utd2lkdGg9Ii4wNzYiLz48cGF0aCBkPSJNMzguMjE3IDQzLjA0NGMtMy4wMjMtMS4yNTMtNy40MTctMS44OC0xMy4xNjYtMS44OC01Ljg3NiAwLTEwLjMxMy42NDQtMTMuMzI3IDEuOTMxIDIuODk2IDEuMTQzIDcuMzE2IDEuNzEgMTMuMjUgMS43MSAyLjg0NSAwIDUuNDQ1LS4xNTIgNy43OTgtLjQ2NSAyLjM2My0uMzE0IDQuMTc1LS43NDUgNS40NDUtMS4yOTZ6TTI0Ljk0OSA5LjAxN2MxLjExIDAgMS42Ni0uNTYgMS42Ni0xLjY2IDAtMS4wOTItLjU1LTEuNjQyLTEuNjYtMS42NDItMS4wOTIgMC0xLjYzNC41NS0xLjYzNCAxLjY0MiAwIDEuMS41NDIgMS42NiAxLjYzNCAxLjY2em0xMi42MjQgMjQuOTc2Yy0zLjE5Mi0uODEyLTcuMzY2LTEuMjEtMTIuNTIyLTEuMjEtNS4yOTIgMC05LjUxNy40MDYtMTIuNjc1IDEuMjM2bC4zNzMgMi4zNzljMy4yMTctLjc2MiA3LjMyMy0xLjE0MyAxMi4zMDItMS4xNDMgNC45NDQgMCA4Ljk3NS4zNzIgMTIuMDk5IDEuMTE3em0uNjE4LTEuNDlsMS42MTctMi44NTNhNi40MzIgNi40MzIgMCAwIDEtMi40My40NzRjLTIuMjE4IDAtMy45ODctLjg5Ny01LjMwOC0yLjctLjk5LjgyLTIuMSAxLjIzNS0zLjMyOCAxLjIzNS0xLjU4MyAwLTIuODUzLS42MTgtMy43OTMtMS44NjItMS4wNTggMS4xNi0yLjMyIDEuNzQ0LTMuNzkzIDEuNzQ0LTEuMTk0IDAtMi4yODYtLjQwNi0zLjI3Ni0xLjIyLTEuMzg5IDEuNzctMy4xODQgMi42NS01LjM4NSAyLjY1YTcuMDU1IDcuMDU1IDAgMCAxLTIuNTA2LS40NjVsMS43MzUgMi45NzJjMy4yMS0uOTIzIDcuNjItMS4zODkgMTMuMjI1LTEuMzg5IDUuNzA3IDAgMTAuMTE4LjQ3NCAxMy4yNDIgMS40MTR6bS0xMS4xMDgtNS45MjZsLTIuMTA4LTEyLjEzMy0yLjEwOSAxMS45ODljLjA1MS0uMDM0LjE2MS0uMTE5LjM0OC0uMjU0LjM4LS43NDUuOTU2LTEuMTE4IDEuNzM1LTEuMTE4Ljg0NyAwIDEuMzg5LjM3MyAxLjYzNCAxLjExOC4xMDIuMTAxLjI3MS4yMzcuNS4zOTh6bTYuODY2LjQ3NFYxNS41NmwtNC4wOSAxMS4yNjFjLjMxNC0uMTEuNTc3LS4yNjIuNzk3LS40NC4zMy0uNDE1Ljc3OS0uNjI3IDEuMzM4LS42MjcuNjYgMCAxLjE5My4yOTcgMS41OTEuODcyLjA0My4wNjguMTAyLjEzNi4xNy4yMTIuMDY3LjA3Ni4xMzUuMTQ0LjE5NC4yMTJ6bS0xMy45MzYtLjM0N0wxNS45NSAxNS41NjJ2MTEuMzM2Yy4wNDMtLjA2Ny4xMTktLjE0NC4yMi0uMjQ1LjMzLS42OTQuODcyLTEuMDQyIDEuNjM0LTEuMDQyLjYyNyAwIDEuMTQzLjI2MyAxLjU0MS43OTYuNDQ5LjE5NS42Ny4yOTcuNjcuMjk3em0tNi4zIDEuMzg4TDguMzggMTguODlsMS4zNjMgOC4zODJjLjk0LjY2IDEuODYzLjk5IDIuNzUyLjk5LjM0NyAwIC43NTMtLjA1OSAxLjIxOS0uMTY5em0yMi4zOTUuMTE5Yy4zODEuMTE4LjgwNS4xNzggMS4yNy4xNzggMS4wMDggMCAxLjk0OC0uMzE0IDIuODI4LS45NGwxLjM2My04LjU4NXptMS40OSAxMi41NTZsLS43NDUtMi44MDNjLTMuMjQyLS43MS03LjIwNS0xLjA2Ni0xMS45MDQtMS4wNjYtNC42NDggMC04LjYxLjM1NS0xMS44NzggMS4wNjZsLS43NzEgMi44MjhjMy4wNzMtLjkzMSA3LjI5OC0xLjM4OCAxMi42NzUtMS4zODggNS4yNCAwIDkuNDQ4LjQ0OCAxMi42MjMgMS4zNjN6TTE0LjUzNSAxMC4yNTNjMS4wODQgMCAxLjYzNC0uNTQyIDEuNjM0LTEuNjM0cy0uNTUtMS42MzQtMS42MzQtMS42MzRjLTEuMTA5IDAtMS42NjguNTQyLTEuNjY4IDEuNjM0cy41NiAxLjYzNCAxLjY2OCAxLjYzNHptMjAuODI4IDBjMS4xMSAwIDEuNjY4LS41NDIgMS42NjgtMS42MzRzLS41NTktMS42MzQtMS42NjgtMS42MzRjLTEuMDgzIDAtMS42MzQuNTQyLTEuNjM0IDEuNjM0cy41NSAxLjYzNCAxLjYzNCAxLjYzNHpNNS40IDEyLjk4OGMxLjEwOSAwIDEuNjY4LS41NSAxLjY2OC0xLjY0MyAwLTEuMTEtLjU2LTEuNjYtMS42NjgtMS42Ni0xLjA4NCAwLTEuNjM0LjU1LTEuNjM0IDEuNjYgMCAxLjA5Mi41NSAxLjY0MyAxLjYzNCAxLjY0M3ptMzkuMTQxIDBjMS4wOTIgMCAxLjY0My0uNTUgMS42NDMtMS42NDMgMC0xLjExLS41NS0xLjY2LTEuNjQzLTEuNjYtMS4xIDAtMS42Ni41NS0xLjY2IDEuNjYgMCAxLjA5Mi41NiAxLjY0MyAxLjY2IDEuNjQzeiIgZmlsbD0idXJsKCNhKSIgc3Ryb2tlPSIjMWYxYTE3IiBzdHJva2Utd2lkdGg9Ii4wNzYiLz48L3N2Zz4=";
images.K = new Image(); images.K.src = "data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI1MG1tIiBpbWFnZS1yZW5kZXJpbmc9Im9wdGltaXplUXVhbGl0eSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHRleHQtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHZpZXdCb3g9IjAgMCA1MCA1MCIgd2lkdGg9IjUwbW0iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIxLjM3NiIgeDI9Ijc3LjY0MSIgeTE9IjM3LjM0NiIgeTI9IjM3LjM0NiI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmIiBzdG9wLW9wYWNpdHk9IjAiLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGQ9Ik0yNS44MjEgMTIuMDIyaC0xLjc2di0zLjI1aC0yLjA2N2MtLjU1OCAwLS44MzgtLjI3Mi0uODM4LS44MjJ2LS4wMjVjMC0uNTQyLjI4LS44MTMuODM4LS44MTNoMi4wNjZWNS4wMDRjMC0uNTg1LjI5Ny0uODcyLjg5LS44NzIuNTc1IDAgLjg3MS4yODcuODcxLjg3MnYyLjEwOGgyLjEzNGMuNTQyIDAgLjgxMy4yNy44MTMuODEzdi4wMjVjMCAuNTUtLjI3MS44MjEtLjgxMy44MjFsLTIuMTE3LjAyNnpNMTEuMDMgMzcuNzQ0bC0uODEzLTQuNjRjLS4wMTcgMC0uMDQyLS4wMzMtLjA3Ni0uMTAxLS4wODUtLjExOS0uMzIyLS4yNzEtLjcxMS0uNDU3LS4zODEtLjE5NS0uODM4LS41MTctMS4zNDYtLjk4MmE0MS45OSA0MS45OSAwIDAgMS0xLjcwMi0xLjQ5IDguNTA5IDguNTA5IDAgMCAxLTEuMS0xLjIzN0M0LjI3MyAyNy40NSAzLjcwNSAyNS43NzIgMy41OTUgMjMuOGMtLjE3LTEuODk3LjYwMS0zLjc5NCAyLjMwMy01LjY4MiAxLjcxOS0xLjg4IDQuMDQ3LTIuNzY4IDYuOTY4LTIuNjUgMS4wOTIuMDY4IDIuMzguMzMgMy44NDQuNzk2LjQ4My4xOTUuOTc0LjM5IDEuNDgyLjU3NmwxLjQ5OC41ODRjLjI2My4xMzYuNS4yNzEuNjk1LjM5OGE0LjM4IDQuMzggMCAwIDEtLjEyNy0xLjA0MWMwLTEuMjg3LjQ1Ny0yLjM4OCAxLjM4LTMuMzAyLjkxNC0uOTA2IDIuMDIzLTEuMzcyIDMuMzEtMS4zODkgMS4yODcgMCAyLjM4OC40NjYgMy4zMDIgMS4zOC45MDYuOTE1IDEuMzYzIDIuMDE1IDEuMzYzIDMuMjg1IDAgLjI2My0uMDM0LjYxLS4xMDEgMS4wNDIuMjI4LS4xNDQuNDU3LS4yNzEuNjY5LS4zNzMuNzYyLS4zMyAxLjc2LS43MiAzLjAwNS0xLjE2IDEuNDIzLS40ODIgMi43MDEtLjc1MyAzLjg0NC0uODIxIDIuOTIxLS4xMzYgNS4yNDEuNzUzIDYuOTQzIDIuNjUgMS42NjggMS44ODggMi40NDcgMy43ODUgMi4zMjggNS42ODEtLjEyNyAxLjk3My0uNzAzIDMuNjUtMS43MSA1LjAzOC0uMzMuNDQ5LS43MDMuODYzLTEuMTE4IDEuMjUzYTQwLjUgNDAuNSAwIDAgMS0xLjY2IDEuNDczYy0uNTQxLjQ2Ni0xLjAwNy43OTYtMS4zODguOTgyLS4zOC4xODYtLjYuMzQ3LS42NjkuNDU3YS4yOTQuMjk0IDAgMCAxLS4wNS4wNzdjLS4wMTcuMDE3LS4wMjYuMDM0LS4wMjYuMDVsLS43OTYgNC42NjYgMS42NDMgNi4xMjFjLS44My43NDUtMi42ODQgMS4zNTUtNS41NTQgMS44MzctMi44NzkuNDgzLTYuMjA2LjcyLTkuOTc0LjcyLTMuODM1IDAtNy4yMTQtLjI1NC0xMC4xMTgtLjc1NC0yLjkxMi0uNTA4LTQuNzQxLTEuMTQzLTUuNDg2LTEuODk2eiIgZmlsbD0iIzFmMWExNyIvPjxwYXRoIGQ9Ik0yNS43OTYgMjkuNTMyYzIuODQ1LjAzMyA1LjQ0NC4yMDMgNy44MDYuNTA4IDIuMzcuMzA0IDQuMjI1LjY5NCA1LjU2MyAxLjE1MWExMjYuMzIgMTI2LjMyIDAgMCAwIDIuMDU3LTEuNjUxIDEyLjAxOCAxMi4wMTggMCAwIDAgMS44NjMtMS44NDZjLjc4Ny0xLjAwNyAxLjE4NS0yLjMzNyAxLjE4NS0zLjk5NiAwLTEuNDgyLS4zNTYtMi43MjYtMS4wNjctMy43MTctMS4yNy0xLjg1NC0zLjIwOS0yLjc3Ny01LjgtMi43NzctMS41NTcgMC0zLjE0OS4zMjItNC43OTIuOTY1LTEuNDM5LjU4NC0yLjUzMSAxLjIyOC0zLjI2OCAxLjk0LTEuMzg4IDEuMzg4LTIuNDIxIDMuMTc0LTMuMDgyIDUuMzUtLjIyOC43NzktLjM2NCAxLjQ5LS40MDYgMi4xMjUtLjA0Mi42MzUtLjA2IDEuMjg3LS4wNiAxLjk0N3ptLTEzLjI1IDYuNjk3YzMuMTQtLjc5NiA3LjMwNi0xLjE5NCAxMi41MDUtMS4xOTQgNS4wODggMCA5LjIwMy4zOCAxMi4zMjcgMS4xNDNsLjYxOC0zLjY1Yy0zLjMyNy0uODcxLTcuNjctMS4zMTItMTMuMDQ3LTEuMzEyLTUuNDEgMC05Ljc0NS40NS0xMy4wMjIgMS4zMzh6bTI1LjI5OCA0LjQxbC0uNzM3LTIuODQ0Yy0zLjI3Ni0uNzI4LTcuMzMyLTEuMDkyLTEyLjE1OC0xLjA5Mi00LjgwOSAwLTguODU2LjM2NC0xMi4xMzMgMS4wOTJsLS43ODcgMi44N2MzLjE1OC0uOTIzIDcuNDY4LTEuMzg4IDEyLjk0Ni0xLjM4OCA1LjQ0NCAwIDkuNzI4LjQ1NyAxMi44NjkgMS4zNjN6bS42NTIgMi4zMzhjLTMuMTkyLTEuMjg3LTcuNjgtMS45NC0xMy40NDUtMS45NC01Ljk4NiAwLTEwLjUxNi42NjEtMTMuNTk4IDEuOTkgMi45MTMgMS4xNTIgNy40MTcgMS43MzYgMTMuNTIyIDEuNzM2IDIuOTEyIDAgNS41NjItLjE2IDcuOTU4LS40ODMgMi40MDUtLjMyMSA0LjI1LS43NjIgNS41NjMtMS4zMDN6TTI0LjA3NyAyOS41MzJjLS4wMDgtLjY0NC0uMDM0LTEuMjg3LS4wNjgtMS45MjJzLS4xNi0xLjM0Ny0uMzcyLTIuMTI2Yy0uNjc3LTIuMjEtMS43MDItMy45OTYtMy4wODItNS4zNS0uNzExLS42OTUtMS43OTUtMS4zNDctMy4yNjgtMS45NC0xLjY4NS0uNjYtMy4yODUtLjk5LTQuNzkyLS45OS0yLjYwOCAwLTQuNTQ3LjkzMS01LjggMi44MDMtLjcxMS45OS0xLjA2NyAyLjIzNS0xLjA2NyAzLjcxNiAwIDEuNjI2LjM5OCAyLjk1NSAxLjE4NiAzLjk5Ny40ODIuNjEgMS4wOTIgMS4yMjcgMS44MzcgMS44MzcuNzQ1LjYxIDEuNDQgMS4xNjggMi4wODMgMS42NiAyLjg5NS0xLjA0MiA3LjM0LTEuNiAxMy4zNDMtMS42ODV6bS44NzItNC42MTVjLjExOS0uNDY1LjIxMi0uNzg3LjI5Ni0uOTY1LjE3LS42NDMuMzU2LTEuMTk0LjU3Ni0xLjY0My4wOTMtLjI3OS4yMzctLjYuNDMyLS45NzMuMTg2LS4zNzMuMzktLjgwNS42MS0xLjI3OS4xMjctLjI4LjI3LS42MjYuNDE1LTEuMDMzLjE1Mi0uNDA2LjMwNC0uODA0LjQ0OC0xLjIwMi4xMzYtLjMzLjIwMy0uNjg2LjIwMy0xLjA2NyAwLS44MTMtLjI5Ni0xLjQ5OC0uODcyLTIuMDY2LS41NzUtLjU3NS0xLjI3OC0uODYzLTIuMTA4LS44NjMtMS45NjQgMC0yLjk1NS45OS0yLjk1NSAyLjk1NSAwIC4zOC4wNjguNzM2LjIwMyAxLjA2Ny4zNjUgMS4wNzUuNjQ0IDEuODIuODM5IDIuMjM1LjIyLjQ3NC40MTUuOTA2LjYgMS4yNzguMTc5LjM3My4zNC42OTQuNDY2Ljk3NC4yMi41NS4zOTggMS4wOTIuNTUgMS42NDIuMDM1LjA5NC4xMjguNDE1LjI5Ny45NHoiIGZpbGw9InVybCgjYSkiLz48L3N2Zz4=";
images.p = new Image(); images.p.src = "data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI1MG1tIiBpbWFnZS1yZW5kZXJpbmc9Im9wdGltaXplUXVhbGl0eSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHRleHQtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHZpZXdCb3g9IjAgMCA1MCA1MCIgd2lkdGg9IjUwbW0iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTI1IDQ2LjQ0OEgxMS42MDZhMTMuMTM5IDEzLjEzOSAwIDAgMS0uOTktNS4wNDNjMC0yLjk3NS44NjMtNS42NDQgMi41OTgtOC4wMTggMS43MzYtMi4zNjUgMy45NzEtNC4wNTQgNi42OTctNS4wNjdhNi44MjQgNi44MjQgMCAwIDEtMi44NjEtMi4zOThjLS43MzctMS4wNzEtMS4xLTIuMjgzLTEuMS0zLjYzNCAwLTEuNjkuNTc1LTMuMTU2IDEuNzM1LTQuMzkyIDEuMTUxLTEuMjQ0IDIuNTc0LTEuOTYxIDQuMjY3LTIuMTUtMS4zNDYtLjk4MS0yLjAxNS0yLjI4My0yLjAxNS0zLjg5IDAtMS4zNTEuNDkxLTIuNTEzIDEuNDgyLTMuNDc3Ljk4Mi0uOTY0IDIuMTc2LTEuNDQyIDMuNTgxLTEuNDQyIDEuMzg5IDAgMi41ODIuNDc4IDMuNTczIDEuNDQyczEuNDkgMi4xMjYgMS40OSAzLjQ3N2MwIDEuNjA3LS42NjkgMi45MDktMi4wMTUgMy44OSAxLjY5My4xODkgMy4xMTYuOTA2IDQuMjY3IDIuMTUgMS4xNiAxLjIzNiAxLjczNiAyLjcwMyAxLjczNiA0LjM5MiAwIDEuMzUxLS4zNzMgMi41NjMtMS4xMjYgMy42MzRhNy4wMzYgNy4wMzYgMCAwIDEtMi44NjIgMi4zOThjMi43MjYgMS4wMTMgNC45NjIgMi43MDIgNi42OTcgNS4wNjcgMS43MzYgMi4zNzQgMi42IDUuMDQzIDIuNiA4LjAxOCAwIDEuNzM5LS4zMjIgMy40Mi0uOTY2IDUuMDQzeiIgZmlsbD0iIzFmMWExNyIvPjwvc3ZnPg==";
images.n = new Image(); images.n.src = "data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI1MG1tIiBpbWFnZS1yZW5kZXJpbmc9Im9wdGltaXplUXVhbGl0eSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHRleHQtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHZpZXdCb3g9IjAgMCA1MCA1MCIgd2lkdGg9IjUwbW0iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIxLjI1MyIgeDI9Ijc3LjY0MSIgeTE9IjM3LjU5MiIgeTI9IjM3LjQ2OSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmIiBzdG9wLW9wYWNpdHk9IjAiLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGQ9Ik0yNi4xNzggOS4zOTVjMi42LjE3IDUuMDA0LjgzOCA3LjIyMiAyLjAxNSAyLjIxIDEuMTY5IDQuMDk4IDIuNjc2IDUuNjU2IDQuNTEzIDEuMDkyIDEuMjg3IDIuMTE3IDIuODQ1IDMuMDgyIDQuNjY1YTI4LjY4NCAyOC42ODQgMCAwIDEgMi4zMiA1Ljc3NCAzNi41MTEgMzYuNTExIDAgMCAxIDEuMjUzIDcuNDZjLjE3NyAyLjU5OS4yNjIgNS4wMTIuMjYyIDcuMjN2NS40MDJIMTUuNDY4Yy0uMTUzIDAtLjIyLS40MDctLjIxMi0xLjIxLjAwOS0uODE0LjA2LTEuNDY2LjE2LTEuOTY1LjA2LS4zOTguMjIxLS45NTcuNDY3LTEuNjg1LjI1NC0uNzI4LjY2LTEuNjA5IDEuMjQ0LTIuNjUuMjYzLS41MzQuODktMS4zMDQgMS44OC0yLjMyLjk5OS0xLjAxNiAyLjEzMy0yLjIwMSAzLjQyOS0zLjUzOS43NDUtLjc2MiAxLjMyLTEuNzE5IDEuNzQ0LTIuODc5LjQyMy0xLjE1MS42MDEtMi4yMDEuNTMzLTMuMTVhOC4zNyA4LjM3IDAgMCAxLTIuMDA2IDEuMjJjLTMuNTA1IDEuMjUzLTYuMDQ1IDMuMDczLTcuNjEyIDUuNDUyLS4xMTguMTUzLS40OS44MjItMS4xMTcgMi4wMTUtLjMzLjYyNy0uNjE4IDEuMDU5LS44NDcgMS4yODctLjMxMy4zMTQtLjc3LjQ5MS0xLjM2My41MjUtLjkyMy4wNDMtMS42NDMtLjM5OC0yLjE2LTEuMzQ2LS42OTMuMjAzLTEuMzEyLjI4OC0xLjg2Mi4yNTQtLjkyMy0uMzQ3LTEuNTkyLS43Mi0yLjAwNi0xLjExNy0uODQ3LS44NDctMS4zODktMS42ODUtMS42NTEtMi41MzJhOS40MyA5LjQzIDAgMCAxLS4zODEtMi43MjZjMC0xLjM4OS44NTUtMy4yMjYgMi41ODItNS41MTIgMi4wMTUtMi42MjUgMy4wOS00LjYzMSAzLjIxNy02LjAwMyAwLS41OTMuMDYtMS4yNjEuMTc4LTIuMDA3YTQuMTk4IDQuMTk4IDAgMCAxIC42MTgtMS40OWMuMjItLjMzLjM2NC0uNTU4LjQzMi0uNjc3LjA3Ni0uMTI3LjIxMi0uMzEzLjQxNS0uNTU5LjE0NC0uMjAzLjI3LS4zNTUuMzcyLS40NTcuMDkzLS4xMS4yMi0uMjU0LjM3My0uNDQuMTc4LS4yMTIuNDA2LS40NTcuNjk0LS43NDVhMTguMDYgMTguMDYgMCAwIDEtMS4wNjctNy40NmMzLjI4NSAxLjE2OSA2LjA1NCAzLjAxNSA4LjI4IDUuNTMuNTUxLTEuODcyIDEuNjI2LTMuMzg3IDMuMjI2LTQuNTM5IDEuMzIxLjkyMyAyLjM3MSAyLjE1IDMuMTUgMy42NjZ6IiBmaWxsPSIjMWYxYTE3Ii8+PHBhdGggZD0iTTE1LjY4OCAxNy43ODZsLjU0Mi0uMjhjLjUtLjE5NC42NTItLjU1OS40NzQtMS4wOTItLjE5NS0uNDkxLS41NzYtLjY2LTEuMTQzLS40OTEtMS45NDcuNzExLTMuMjk0IDIuMDE1LTQuMDM5IDMuOTItLjExOC41NDIuMDc2LjkxNC41OTMgMS4xMTguNTE2LjE2Ljg2NC0uMDE3IDEuMDQxLS41NS4xMzYtLjI4LjIyOS0uNDY2LjI5Ny0uNTQzLjE4Ni4xNDQuNDIzLjI0Ni43Mi4yOTcgMS4wMDcuMTYgMS42LS4yOCAxLjc2LTEuMzM4YTEuNDk4IDEuNDk4IDAgMCAwLS4yNDUtMS4wNDF6TTExLjU3MyAzNC41NWMuMDYtLjE1My4xNy0uMzczLjMyMi0uNjcuMjgtLjY5My40MTUtMS4xMDguNDE1LTEuMjQ0LS4wMjYtLjQ1Ny0uMjcxLS42OTQtLjcyLS42OTQtLjMzIDAtLjcxMS40NzQtMS4xNiAxLjQxNGEuOTcuOTcgMCAwIDEtLjI5Ni4zNDdjLS40NDkuNDY2LS4zODEuODU1LjE5NCAxLjE2OC41MzQuMzE0Ljk0LjIxMiAxLjI0NS0uMzIxem0xNC42My05LjIwNGMxLjE2LTEuNTI0IDEuNzI4LTMuMjE3IDEuNzEtNS4wOC0uMDY3LS41NS0uMzgtLjgyLS45NC0uODItLjc2MSAwLTEuMDU3LjI3OS0uODk3LjgzNy4wNTEuOTE1LS4wMzMgMS42NjgtLjI3IDIuMjYxLS4zODIuOTQtLjgwNSAxLjY0My0xLjI2MiAyLjEwOC0uMjU0LjUtLjEwMi44NjQuNDQ5IDEuMDkyLjUyNS4yNDYuOTMxLjExOSAxLjIxLS4zOTh6TTE5LjcyNiAxMy4yNGE2Ljc5OCA2Ljc5OCAwIDAgMSAuMDUxLTEuOTNjLS45OS4xOTQtMS45MjIuNjYtMi44MDIgMS4zODgtLjUyNS4yOC0uNjUyLjY3LS4zNzMgMS4xNjkuMjguNTA4LjY3LjU5MiAxLjE2OS4yNDUuMzQ3LS4xODYuNjY5LS4zNTUuOTU2LS41MDguMjg4LS4xNi42MTgtLjI4IDEtLjM2NHptMjMuMjUgMzEuNDU0Yy0uMDE3IDAgMC0uNDQ5LjA0Mi0xLjM0Ni4xMzEtMy4xMDguMDk2LTYuMjIxLjA3Ni05LjMzYTI2LjgzNyAyNi44MzcgMCAwIDAtLjg4OS02LjYxM2MtLjg0LTMuMzEtMi4xMjQtNi40ODUtNC4wNzItOS4yOTctMi42MzQtMy44NDUtNi44MTQtNi4wMzMtMTEuMjg2LTYuOTc2LjEyNi43NjYuMDMzIDEuNTQuMDc2IDIuMzExYTI1LjgyIDI1LjgyIDAgMCAxIDQuNTM4IDIuMDMyYzQuMjQxIDIuNTU1IDYuNDE0IDcuMjc2IDcuMTk3IDExLjkzIDEuMjcyIDYuMTU0LjQ1MyAxMS41NTcuODEzIDE3LjI4OXpNOS40MzkgMzAuMTM5Yy40NzUtLjM0LjUyNS0uNzI5LjE0NC0xLjE5NC0uMzk4LS4zODEtLjgzLS40MTUtMS4zMTItLjEwMi0xLjAwNy42Ni0xLjU1IDEuNTMzLTEuNjE3IDIuNjA4LjAxNy41NDIuMzQ3LjgwNC45NzQuNzcuNTkyLS4wNS44OC0uMzU1Ljg2My0uOTIyLjEzNi0uNTI1LjQ0OS0uOTE1Ljk0OC0xLjE2eiIgZmlsbD0idXJsKCNhKSIvPjwvc3ZnPg==";
images.b = new Image(); images.b.src = "data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI1MG1tIiBpbWFnZS1yZW5kZXJpbmc9Im9wdGltaXplUXVhbGl0eSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHRleHQtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHZpZXdCb3g9IjAgMCA1MCA1MCIgd2lkdGg9IjUwbW0iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIxLjA5NCIgeDI9Ijc3LjY2OSIgeTE9IjM3LjEwMSIgeTI9IjM3LjQ2OSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmIiBzdG9wLW9wYWNpdHk9IjAiLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGQ9Ik0yNSA0Mi4xNjJjLS4yMjkuOTQtLjUxNiAxLjU5Mi0uODQ3IDEuOTU2LS4zMy4zNjQtLjc2Mi43NDUtMS4zMTIgMS4xNDMtLjU5My40MTUtMS4yOTUuNzYyLTIuMTA4IDEuMDUtLjgxMy4yODgtMS43MS4zNjQtMi43MDEuMjExbC02Ljk2OC0uOTY1YTIuODU4IDIuODU4IDAgMCAwLS43NjIgMGMtLjIyLjAzNC0uNDMyLjA1MS0uNjM1LjA1MS0uMzQ3IDAtLjc4Ny4wNzYtMS4zMi4yMzctLjU0My4xNTMtLjk1OC4zODEtMS4yNTQuNjc3bC0yLjQwNS0zLjk0NWMuMjk3LS4zMy41Ni0uNTU5Ljc4OC0uNjk0LjIzNy0uMTI3LjUwOC0uMjcxLjgyMS0uNDE1YTkuMTc5IDkuMTc5IDAgMCAxIDMuMDczLS44MjFjLjQ2Ni0uMDM0LjkyMy0uMDQzIDEuMzY0LS4wMjZhOS44IDkuOCAwIDAgMCAxLjM5Ny0uMDVjLjg4OS4xNTIgMS43ODYuMjg3IDIuNjg0LjQwNi45MDUuMTI3IDEuODExLjI1NCAyLjcxNy4zOS45OTEgMCAxLjY2LS4xMDIgMi4wMDctLjI5Ny4xODYtLjEwMi40NzQtLjI4OC44NzItLjU1LjM5OC0uMjYzLjc5Ni0uNjUyIDEuMTk0LTEuMTY5LS44OC0uMDkzLTEuNzctLjI2Mi0yLjY4NC0uNTA4YTI0LjA5NCAyNC4wOTQgMCAwIDEtMi40MDUtLjc1M2wyLjU4My02LjQwMWMtMS4yOTYtLjc0NS0yLjE5My0xLjMzOC0yLjcxLTEuNzk1YTUuMyA1LjMgMCAwIDEtMS4yMS0xLjU3NWMtLjQzMi0uNzYyLS43MTItMS40OTgtLjgzLTIuMjFhOS4zNDEgOS4zNDEgMCAwIDEtLjE2LTEuOTEzYy4wMTYtLjk5LjI0NS0yLjA4My43MDItMy4yODUuNDU3LTEuMTk0IDEuMzEyLTIuMjcgMi41NjUtMy4yMDlhNzkuMDkxIDc5LjA5MSAwIDAgMCAzLjA1Ny0yLjQ1NSAyNy43NDYgMjcuNzQ2IDAgMCAwIDIuOTQ2LTIuOTU1Yy0xLjIyLS42MjctMS44MjktMS42MjYtMS44MjktMi45OTcgMC0uOTMyLjMyMi0xLjcyLjk3NC0yLjM4OC42NTItLjY2IDEuNDU2LS45OSAyLjM5Ni0uOTkuOTIzIDAgMS43MTkuMzMgMi4zOC45OS42Ni42NjkuOTkgMS40NTYuOTkgMi4zODggMCAxLjM1NC0uNjEgMi4zNTMtMS44MyAyLjk5N2EyNi43OTYgMjYuNzk2IDAgMCAwIDIuOTE0IDIuOTU1IDU2Ljc0IDU2Ljc0IDAgMCAwIDMuMDkgMi40NTVjMS4yMzYuOTQgMi4wODMgMi4wMTUgMi41MjMgMy4yMDkuNDQ5IDEuMjAyLjY5NCAyLjI5NC43MiAzLjI4NSAwIC41NjctLjA1MSAxLjIwMi0uMTcgMS45MTNzLS4zOCAxLjQ0OC0uNzk2IDIuMjFhNi4wODQgNi4wODQgMCAwIDEtMS4yNTMgMS41NzVjLS41LjQ1Ny0xLjM4OCAxLjA1LTIuNjY3IDEuNzk1bDIuNTgzIDYuNGMtLjcyOS4yNjMtMS41NS41MTctMi40NTYuNzU0LS45MTQuMjQ2LTEuNzg2LjQxNS0yLjYzMy41MDguMzgxLjUxNy43Ny45MDYgMS4xNjggMS4xNjkuMzk4LjI2Mi42OTUuNDQ4Ljg5OC41NS4zNDcuMTk1IDEuMDE2LjI5NiAyLjAwNy4yOTZhMjYzLjM1IDI2My4zNSAwIDAgMSAyLjY5Mi0uMzkgODEuMTMgODEuMTMgMCAwIDAgMi43MTgtLjQwNmMuNDQuMDUxLjg4OS4wNjggMS4zNDYuMDUxYTEzLjEyIDEzLjEyIDAgMCAxIDEuNDA1LjAyNiA5LjYyNyA5LjYyNyAwIDAgMSAzLjA3NC44MmMuMjk2LjE0NS41NjcuMjg5LjgwNC40MTYuMjQ2LjEzNS41MDguMzY0LjgwNC42OTRsLTIuNDMgMy45NDVjLS4yOTYtLjI5Ni0uNzEtLjUyNC0xLjI1My0uNjc3LS41MzMtLjE2LS45NjUtLjIzNy0xLjI5NS0uMjM3LS4yMiAwLS40NC0uMDE3LS42Ni0uMDVhMi43OTQgMi43OTQgMCAwIDAtLjc1NCAwbC02Ljk1Ljk2NGMtLjk5Mi4xNTMtMS45MTQuMDg1LTIuNzYxLS4xOTQtLjg1NS0uMjgtMS41NTgtLjY1Mi0yLjEtMS4xMTgtLjU0Mi0uNDQ5LS45ODItLjgzLTEuMzA0LTEuMTUxLS4zMjEtLjMyMi0uNTkyLS45NTctLjgwNC0xLjg5N3oiIGZpbGw9IiMxZjFhMTciLz48cGF0aCBkPSJNMjQuMDg2IDIzLjcwNXYyLjEwOGMwIC42MS4zMDQuOTE0LjkxNC45MTRzLjkxNC0uMzA0LjkxNC0uOTE0di0yLjEzNGgyLjIzNmMuNTc1IDAgLjg3Mi0uMjk2Ljg3Mi0uODk3IDAtLjU5My0uMjk3LS44ODktLjg3Mi0uODg5aC0yLjIzNnYtMi4yMzVjMC0uNjEtLjMwNC0uOTE1LS45MTQtLjkxNXMtLjkxNC4zMDUtLjkxNC45MTV2Mi4yMzVIMjEuOWMtLjU4NCAwLS44NzIuMjk2LS44NzIuODg5IDAgLjYwMS4yODguODk3Ljg3Mi44OTd6bTcuNTEgMTMuNzQxbC0xLjA0Mi0yLjUzMWMtMS42ODUtLjM2NC0zLjUzOS0uNTQyLTUuNTU0LS41NDItMS45OTggMC0zLjgzNS4xNzgtNS41MDMuNTQybC0xLjA0MiAyLjUwNmMyLjA1LS41MTcgNC4yMzQtLjc3IDYuNTQ1LS43NyAyLjI4NiAwIDQuNDc5LjI2MiA2LjU5Ni43OTV6bS0yLjA4My01LjExNGwtLjcyLTEuNzM1di0uNjdhMjcuMDMgMjcuMDMgMCAwIDAtMy43OTMtLjI3IDI3LjM1IDI3LjM1IDAgMCAwLTMuNzY4LjI3bC0uMDI1LjY3LS42NjkgMS43MzVBMjUuODUgMjUuODUgMCAwIDEgMjUgMzEuOTZjMS41OTIgMCAzLjA5LjEyNyA0LjUxMy4zNzJ6bS0uODY0IDkuMzgxYy0uNjYtLjUtMS4zMy0xLjI4Ny0xLjk5LTIuMzYyaC0uNzg3YzAgLjgxMy4xODYgMS42LjU2NyAyLjM2MnptLTUuMTE0IDBjLjM4MS0uODEyLjU3Ni0xLjYuNTc2LTIuMzYyaC0uNzk2Yy0uNjQzIDEuMDU5LTEuMzEyIDEuODQ2LTIuMDE1IDIuMzYyeiIgZmlsbD0idXJsKCNhKSIvPjwvc3ZnPg==";
images.r = new Image(); images.r.src = "data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI1MG1tIiBpbWFnZS1yZW5kZXJpbmc9Im9wdGltaXplUXVhbGl0eSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHRleHQtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHZpZXdCb3g9IjAgMCA1MCA1MCIgd2lkdGg9IjUwbW0iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIxLjE5MiIgeDI9Ijc3LjczNiIgeTE9IjM3LjU1MiIgeTI9IjM3LjQyOSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmIiBzdG9wLW9wYWNpdHk9IjAiLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGQ9Ik0yOC40MDggOS4yMmg0LjIxNlY1LjgyNWg2Ljc5OXY5LjI5NmwtNS41MDMgNC4yNDJ2MTEuODYybDQuMjE2IDQuMjE2djUuMDhoMy43OTN2NS45MjdIOC4wNzFWNDAuNTJoMy43OTN2LTUuMDhsNC4yNDItNC4yMTZWMTkuMzYzbC01LjUwNC00LjI0MlY1LjgyNWg2Ljc3NFY5LjIyaDQuMjQyVjUuODI1aDYuNzl6IiBmaWxsPSIjMWYxYTE3Ii8+PHBhdGggZD0iTTI1LjAxMyAzNS4wNDNoLTEwLjI3TDEzLjYgMzYuMTF2MS40NGgyMi44MjZ2LTEuNDRsLTEuMTQzLTEuMDY3ek0xMy42IDQwLjEyM3YyLjUzMmgyMi44MjZ2LTIuNTMyek0yNS4wMTMgMTMuMDRoLTEyLjd2MS4xNDJsMS44MTIgMS4zNjRoMjEuODAxbDEuNzYxLTEuMzY0VjEzLjA0em0wIDQuMTloLTguNjc5bDEuNDgyIDEuMTY5djEuNDE0aDE0LjM5M3YtMS40MTRsMS40ODItMS4xNjh6bTAgMTMuNTQ3aC03LjE5N3YxLjE0M2wtMS40ODIgMS40NGgxNy4zNTdsLTEuNDgyLTEuNDR2LTEuMTQzeiIgZmlsbD0idXJsKCNhKSIvPjwvc3ZnPg==";
images.q = new Image(); images.q.src = "data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI1MG1tIiBpbWFnZS1yZW5kZXJpbmc9Im9wdGltaXplUXVhbGl0eSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHRleHQtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHZpZXdCb3g9IjAgMCA1MCA1MCIgd2lkdGg9IjUwbW0iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIxLjI1MyIgeDI9Ijc3Ljc2NCIgeTE9IjM3LjIyNCIgeTI9IjM3LjM2Ij48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmYiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmZmYiIHN0b3Atb3BhY2l0eT0iMCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggZD0iTTI0Ljk1IDEwLjc1MmMtLjk0IDAtMS43NDUtLjMzLTIuMzk3LS45OS0uNjUyLS42Ni0uOTc0LTEuNDY1LS45NzQtMi40MDUgMC0uOTMxLjMyMi0xLjcyNy45NzQtMi4zODcuNjUyLS42NiAxLjQ1Ni0uOTkgMi4zOTYtLjk5LjkyMyAwIDEuNzI3LjMzIDIuMzk2Ljk5YTMuMjMgMy4yMyAwIDAgMSAxIDIuMzg3YzAgLjk0LS4zMyAxLjc0NC0xIDIuNDA1LS42NjkuNjYtMS40NzMuOTktMi4zOTYuOTl6bTE1LjI4MSAzMy4xOWMtLjgxMi43MS0yLjYzMyAxLjMwNC01LjQ2IDEuNzg2LTIuODI4LjQ3NC02LjA4OC43Mi05Ljc3MS43Mi0zLjc1IDAtNy4wNTMtLjI1NC05Ljg5OC0uNzQ1LTIuODQ0LS41LTQuNjQtMS4xMTgtNS4zODQtMS44NjNsMS41NjYtNS45NTItLjY5NC0zLjg5NUw4LjQwNSAzMC4yIDYuMjk3IDE0Ljc3NGwxLjIxLS40NzQgNi44IDExLjQ1NS4xNTItMTMuNjQgMS42ODUtLjI5NiA1LjE4MiAxMy43MTYgMi43NzYtMTQuNzU3aDEuNzJsMi43NzYgMTQuNzA2TDMzLjczIDExLjgybDEuNzEuMjk2LjE1MyAxMy42NCA2LjgyNC0xMS40OCAxLjE2LjU0MS0yLjA1OCAxNS4zNTktMi4yMSAzLjc5My0uNjk0IDMuOTQ1ek0xNC41MzUgMTEuOTg5Yy0uOTQ4IDAtMS43NTItLjMyMi0yLjQxMy0uOTc0LS42Ni0uNjUyLS45OS0xLjQ1Ni0uOTktMi4zOTYgMC0uOTIzLjMzLTEuNzE5Ljk5LTIuMzhzMS40NjUtLjk5IDIuNDEzLS45OWMuOTIzIDAgMS43MTkuMzMgMi4zOC45OXMuOTkgMS40NTcuOTkgMi4zOGMwIC45NC0uMzMgMS43NDQtLjk5IDIuMzk2YTMuMjY2IDMuMjY2IDAgMCAxLTIuMzguOTc0em0yMC44MjggMGMtLjk0IDAtMS43MzYtLjMyMi0yLjM4Ny0uOTc0LS42NTItLjY1Mi0uOTgyLTEuNDU2LS45ODItMi4zOTYgMC0uOTIzLjMzLTEuNzE5Ljk4Mi0yLjM4czEuNDQ3LS45OSAyLjM4Ny0uOTljLjk0OCAwIDEuNzUzLjMzIDIuNDEzLjk5cy45OSAxLjQ1Ny45OSAyLjM4YzAgLjk0LS4zMyAxLjc0NC0uOTkgMi4zOTYtLjY2LjY1Mi0xLjQ2NS45NzQtMi40MTMuOTc0ek01LjQgMTQuNzIzYy0uOTQgMC0xLjczNi0uMzMtMi4zODgtLjk4Mi0uNjUyLS42NTItLjk4Mi0xLjQ0OC0uOTgyLTIuMzk2IDAtLjkyMy4zMy0xLjcxOS45ODItMi4zODhDMy42NjQgOC4yOCA0LjQ2IDcuOTUgNS40IDcuOTVjLjk0OCAwIDEuNzQ0LjMzIDIuNDEzIDEuMDA3LjY2LjY3Ljk5IDEuNDY1Ljk5IDIuMzg4IDAgLjk0OC0uMzMgMS43NDQtLjk5IDIuMzk2YTMuMzIzIDMuMzIzIDAgMCAxLTIuNDEzLjk4MnptMzkuMTQxIDBjLS45NCAwLTEuNzQ0LS4zMy0yLjQwNC0uOTgyLS42Ni0uNjUyLS45OTEtMS40NDgtLjk5MS0yLjM5NiAwLS45MjMuMzMtMS43MTkuOTktMi4zODguNjYtLjY3NyAxLjQ2NS0xLjAwNyAyLjQwNS0xLjAwNy45MzEgMCAxLjcyNy4zMyAyLjM4OCAxLjAwNy42Ni42Ny45OSAxLjQ2NS45OSAyLjM4OCAwIC45NDgtLjMzIDEuNzQ0LS45OSAyLjM5NmEzLjI4IDMuMjggMCAwIDEtMi4zODguOTgyeiIgZmlsbD0iIzFmMWExNyIvPjxwYXRoIGQ9Ik0zNy4yIDM1LjczYy0zLjA0LS44NC03LjA5NS0xLjI2Mi0xMi4xNS0xLjI2Mi01LjA5NiAwLTkuMTk0LjQzMS0xMi4zMDEgMS4yODZsLjM3MiAyLjUwN2MzLjEyNC0uODEzIDcuMDk1LTEuMjIgMTEuOTMtMS4yMiA0LjgwOSAwIDguNzI5LjM5OCAxMS43NTIgMS4xOTR6bTEuNzM2LTQuNDM3Yy0xLjM3Mi0uNS0zLjMwMi0uOTA2LTUuNzkxLTEuMjI4LTIuNDktLjMyMi01LjIzMy0uNDgzLTguMjQ3LS40ODMtMi45NDYgMC01LjYzOC4xNTMtOC4wODUuNDU4LTIuNDQ3LjMwNC00LjM3OC43MDItNS43ODMgMS4yMDJsMS4yNDUgMi4yNTJjMS4zODgtLjQwNiAzLjE5MS0uNzAzIDUuNDEtLjg5IDIuMjEtLjE3NyA0LjYzMS0uMjcgNy4yNjQtLjI3czUuMDYzLjA5MyA3LjI5LjI3YzIuMjM1LjE4NyA0LjA0Ny40OTIgNS40MzYuOTE1em0tMS4wOTIgMTEuODUzbC0uNzM3LTIuOTNjLTMuMjI2LS43MzYtNy4yODEtMS4xMDktMTIuMTU4LTEuMTA5LTQuODI2IDAtOC44NjQuMzczLTEyLjEwNyAxLjExbC0uNzg4IDIuOTU0YzMuMTQyLS45NTYgNy40NDMtMS40NCAxMi45Mi0xLjQ0IDIuNjI1IDAgNS4wNzIuMTM2IDcuMzE2LjM5OSAyLjI1Mi4yNjIgNC4xMDYuNjAxIDUuNTU0IDEuMDE2eiIgZmlsbD0idXJsKCNhKSIvPjwvc3ZnPg==";
images.k = new Image(); images.k.src = "data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI1MG1tIiBpbWFnZS1yZW5kZXJpbmc9Im9wdGltaXplUXVhbGl0eSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHRleHQtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iIHZpZXdCb3g9IjAgMCA1MCA1MCIgd2lkdGg9IjUwbW0iIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIxLjEzIiB4Mj0iNzcuNzY0IiB5MT0iMzcuMjI0IiB5Mj0iMzcuNDY5Ij48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmYiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmZmYiIHN0b3Atb3BhY2l0eT0iMCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggZD0iTTI1LjgyMSAxMi4wMjJoLTEuNzZ2LTMuMjVoLTIuMDY3Yy0uNTU4IDAtLjgzOC0uMjcyLS44MzgtLjgyMnYtLjAyNWMwLS41NDIuMjgtLjgxMy44MzgtLjgxM2gyLjA2NlY1LjAwNGMwLS41ODUuMjk3LS44NzIuODktLjg3Mi41NzUgMCAuODcxLjI4Ny44NzEuODcydjIuMTA4aDIuMTM0Yy41NDIgMCAuODEzLjI3LjgxMy44MTN2LjAyNWMwIC41NS0uMjcxLjgyMS0uODEzLjgyMWwtMi4xMTcuMDI2ek0xMS4wMyAzNy43NDRsLS44MTMtNC42NGMtLjAxNyAwLS4wNDItLjAzMy0uMDc2LS4xMDEtLjA4NS0uMTE5LS4zMjItLjI3MS0uNzExLS40NTctLjM4MS0uMTk1LS44MzgtLjUxNy0xLjM0Ni0uOTgyYTQxLjk5IDQxLjk5IDAgMCAxLTEuNzAyLTEuNDkgOC41MDkgOC41MDkgMCAwIDEtMS4xLTEuMjM3QzQuMjczIDI3LjQ1IDMuNzA1IDI1Ljc3MiAzLjU5NSAyMy44Yy0uMTctMS44OTcuNjAxLTMuNzk0IDIuMzAzLTUuNjgyIDEuNzE5LTEuODggNC4wNDctMi43NjggNi45NjgtMi42NSAxLjA5Mi4wNjggMi4zOC4zMyAzLjg0NC43OTYuNDgzLjE5NS45NzQuMzkgMS40ODIuNTc2bDEuNDk4LjU4NGMuMjYzLjEzNi41LjI3MS42OTUuMzk4YTQuMzggNC4zOCAwIDAgMS0uMTI3LTEuMDQxYzAtMS4yODcuNDU3LTIuMzg4IDEuMzgtMy4zMDIuOTE0LS45MDYgMi4wMjMtMS4zNzIgMy4zMS0xLjM4OSAxLjI4NyAwIDIuMzg4LjQ2NiAzLjMwMiAxLjM4LjkwNi45MTUgMS4zNjMgMi4wMTUgMS4zNjMgMy4yODUgMCAuMjYzLS4wMzQuNjEtLjEwMSAxLjA0Mi4yMjgtLjE0NC40NTctLjI3MS42NjktLjM3My43NjItLjMzIDEuNzYtLjcyIDMuMDA1LTEuMTYgMS40MjMtLjQ4MiAyLjcwMS0uNzUzIDMuODQ0LS44MjEgMi45MjEtLjEzNiA1LjI0MS43NTMgNi45NDMgMi42NSAxLjY2OCAxLjg4OCAyLjQ0NyAzLjc4NSAyLjMyOCA1LjY4MS0uMTI3IDEuOTczLS43MDMgMy42NS0xLjcxIDUuMDM4LS4zMy40NDktLjcwMy44NjMtMS4xMTggMS4yNTNhNDAuNSA0MC41IDAgMCAxLTEuNjYgMS40NzNjLS41NDEuNDY2LTEuMDA3Ljc5Ni0xLjM4OC45ODItLjM4LjE4Ni0uNi4zNDctLjY2OS40NTdhLjI5NC4yOTQgMCAwIDEtLjA1LjA3N2MtLjAxNy4wMTctLjAyNi4wMzQtLjAyNi4wNWwtLjc5NiA0LjY2NiAxLjY0MyA2LjEyMWMtLjgzLjc0NS0yLjY4NCAxLjM1NS01LjU1NCAxLjgzNy0yLjg3OS40ODMtNi4yMDYuNzItOS45NzQuNzItMy44MzUgMC03LjIxNC0uMjU0LTEwLjExOC0uNzU0LTIuOTEyLS41MDgtNC43NDEtMS4xNDMtNS40ODYtMS44OTZ6IiBmaWxsPSIjMWYxYTE3Ii8+PHBhdGggZD0iTTI0Ljk1IDIwLjY3NWEyLjI5NSAyLjI5NSAwIDAgMC0uMTI4LS40MjMgNS42MDYgNS42MDYgMCAwIDAtLjI0NS0uNzJjLS4wNTEtLjExLS4xMTktLjI1NC0uMTk1LS40MzFhOS4wMjggOS4wMjggMCAwIDEtLjI1NC0uNTZjLS4wNS0uMTE4LS4xMS0uMjctLjE4Ni0uNDU2LS4wNjgtLjE5NS0uMTM2LS4zNzMtLjE4Ny0uNTM0YTEuNzM1IDEuNzM1IDAgMCAxLS4wNjctLjQ3NGMwLS44NzIuNDE1LTEuMzEyIDEuMjYxLTEuMzEyLjg4IDAgMS4zMTMuNDMxIDEuMzEzIDEuMjg3IDAgLjIyLS4wMzQuMzcyLS4wOTQuNDc0LS4yMzcuNjI2LS4zNTUuOTY1LS4zNzIgMS4wMTYtLjI1NC41LS40MDYuODIxLS40NzQuOTY1LS4xMTkuMjctLjE5NS41MDgtLjIyLjcyLS4wNTEuMTAxLS4wODUuMTg2LS4xMDIuMjYycy0uMDM0LjEzNi0uMDUuMTg2em0tMi43NzggOC41NmMtMi4wNjYuMDM0LTMuOTU0LjEzNi01LjY3My4zMjItMS43MS4xNzgtMy4wMy40NC0zLjk3OS43N2ExOC45NzMgMTguOTczIDAgMCAwLTEuNzE5LTEuODU0IDMzLjAwNyAzMy4wMDcgMCAwIDEtMS43MjctMS43NDRjLS44My0uODQ3LTEuMjM2LTEuNzctMS4yMzYtMi43NzcgMC0xLjI0NS4yMDMtMi4xNS42MTgtMi43MjYuNDQtLjY3IDEuMTM1LTEuMTYgMi4wNTgtMS40ODJhOC40ODYgOC40ODYgMCAwIDEgMi44MDItLjQ4M2MxLjE5NCAwIDIuMzI4LjI2MyAzLjQyLjc5NiAxLjA3Ni41NiAxLjc4NyAxLjAwOCAyLjEzNCAxLjMzOCAxLjEyNiAxLjE0MyAyLjAwNyAyLjM4IDIuNjMzIDMuNzE3LjIxMi41LjM3MyAxLjE5NC40ODMgMi4wNzQuMTEuODkuMTcgMS41NjcuMTg2IDIuMDV6bTIuNzc3LTQuMzE4Yy4xMTktLjQ2Ni4yMTItLjc4Ny4yOTYtLjk2NS4xNy0uNjQzLjM1Ni0xLjE5NC41NzYtMS42NDMuMDkzLS4yNzkuMjM3LS42LjQzMi0uOTczLjE4Ni0uMzczLjM5LS44MDUuNjEtMS4yNzkuMTI3LS4yOC4yNy0uNjI2LjQxNS0xLjAzMy4xNTItLjQwNi4zMDQtLjgwNC40NDgtMS4yMDIuMTM2LS4zMy4yMDMtLjY4Ni4yMDMtMS4wNjcgMC0uODEzLS4yOTYtMS40OTgtLjg3Mi0yLjA2Ni0uNTc1LS41NzUtMS4yNzgtLjg2My0yLjEwOC0uODYzLTEuOTY0IDAtMi45NTUuOTktMi45NTUgMi45NTUgMCAuMzguMDY4LjczNi4yMDMgMS4wNjYuMzY1IDEuMDc2LjY0NCAxLjgyLjgzOSAyLjIzNi4yMi40NzQuNDE1LjkwNi42IDEuMjc4LjE3OS4zNzMuMzQuNjk0LjQ2Ni45NzQuMjIuNTUuMzk4IDEuMDkyLjU1IDEuNjQyLjAzNS4wOTMuMTI4LjQxNS4yOTcuOTR6bS0uODg5IDYuMjIzYzAtLjY2LS4wMTctMS41NzUtLjA1LTIuNzM1LS4wMzQtMS4xNjgtLjE2MS0yLjE0Mi0uMzczLTIuOTItLjY3Ny0yLjIxLTEuNzAyLTMuOTk3LTMuMDgyLTUuMzUxLS43MTEtLjY5NS0xLjc5NS0xLjM0Ny0zLjI2OC0xLjk0LTEuNjg1LS42Ni0zLjI4NS0uOTktNC43OTItLjk5LTIuNjA4IDAtNC41NDcuOTMxLTUuOCAyLjgwMy0uNzExLjk5LTEuMDY3IDIuMjM1LTEuMDY3IDMuNzE2IDAgMS42MjYuMzk4IDIuOTU1IDEuMTg2IDMuOTk3LjQxNS41OTIgMS4yMSAxLjMyOSAyLjM4NyAyLjIxIDEuMTY5Ljg3MiAyLjE2OCAxLjY4NCAyLjk3MiAyLjQzIDEuNDQtLjMxNCAzLjA2NS0uNTg1IDQuODc3LS44MjIgMS44MTItLjIyOSA0LjE0OS0uMzY0IDcuMDEtLjM5OHptMTMuNzg0IDExLjczNWwtLjczNy0yLjkzYy0zLjIyNS0uNzM2LTcuMjgxLTEuMTA5LTEyLjE1OC0xLjEwOS00LjgyNiAwLTguODY0LjM3My0xMi4xMDcgMS4xMWwtLjc4NyAyLjk1NGMzLjE0LS45NTYgNy40NDItMS40MzkgMTIuOTItMS40MzkgMi42MjQgMCA1LjA3MS4xMzYgNy4zMTUuMzk4IDIuMjUyLjI2MiA0LjEwNi42MDEgNS41NTQgMS4wMTZ6bS0uNjQzLTcuNDE3Yy0zLjA0LS44MzgtNy4wOTYtMS4yNjEtMTIuMTUtMS4yNjEtNS4wOTcgMC05LjE5NS40MzEtMTIuMzAyIDEuMjg3bC4zNzIgMi41MDZjMy4xMjUtLjgxMyA3LjA5NS0xLjIyIDExLjkzLTEuMjIgNC44MDkgMCA4LjcyOS4zOTggMTEuNzUyIDEuMTk0em0tMTEuMzYzLTQuMjkyYzIuODQ1LjA1IDUuMTgyLjE5NCA3LjAwMi40MjMgMS44MTIuMjI5IDMuNDU1LjUwOCA0LjkxLjgyMS45MDctLjg5NyAxLjkxNC0xLjc0NCAzLjAyMy0yLjU1N3MxLjg4OC0xLjUwNyAyLjMzNy0yLjA4M2MuNzg4LTEuMDc1IDEuMTg2LTIuNDEzIDEuMTg2LTQuMDIxIDAtMS40NjUtLjM1Ni0yLjcwMS0xLjA2Ny0zLjY5Mi0xLjI3LTEuODctMy4yMTgtMi44MDItNS44MjUtMi44MDItMS41MjQgMC0zLjEwOC4zMy00Ljc2Ny45OS0xLjUwNy41OTMtMi41OSAxLjIzNy0zLjI3NyAxLjkzLTEuNDA1IDEuMzY0LTIuNDMgMy4xNS0zLjA3MyA1LjM2LS4yNDYuNzYyLS4zODEgMS43MjctLjQwNyAyLjkwNHMtLjA0MiAyLjA4My0uMDQyIDIuNzI3em0xLjgxMi0xLjkzYzAtLjQ4My4wNi0xLjE2LjE2LTIuMDUuMTExLS44OC4yOC0xLjU3NS41MDktMi4wNzQuNjE4LTEuMzM4IDEuNDktMi41NzQgMi42MzMtMy43MTcuMzMtLjMzIDEuMDQyLS43NzkgMi4xMzQtMS4zMzhhNy42NTUgNy42NTUgMCAwIDEgMy40NDYtLjc5NmMuOTMgMCAxLjg0NS4xNjEgMi43NjguNDgzLjkxNS4zMjIgMS42MDkuODEzIDIuMDY2IDEuNDgyLjQxNS41NTkuNjI3IDEuNDY0LjYyNyAyLjcyNiAwIC45OS0uNDA3IDEuOTEzLTEuMjIgMi43NzdhNDAuMzUgNDAuMzUgMCAwIDEtMS43MSAxLjY1MWMtLjYxLjU1LTEuMjAyIDEuMjAyLTEuNzYgMS45NDctLjk1OC0uMzMtMi4yOTUtLjU5Mi00LjAwNi0uNzctMS43MS0uMTg2LTMuNTktLjI4OC01LjY0Ny0uMzIyeiIgZmlsbD0idXJsKCNhKSIvPjwvc3ZnPg==";

function XY(s) {				// e.g. "b7" --> [1, 1]
	if (typeof s !== "string" || s.length !== 2) {
		return [-1, -1];
	}
	s = s.toLowerCase();
	let x = s.charCodeAt(0) - 97;
	let y = 8 - parseInt(s[1], 10);
	if (x < 0 || x > 7 || y < 0 || y > 7 || Number.isNaN(y)) {
		return [-1, -1];
	}
	return [x, y];
}

function S(x, y) {				// e.g. (1, 1) --> "b7"
	if (typeof x !== "number" || typeof y !== "number" || x < 0 || x > 7 || y < 0 || y > 7) {
		return "??";
	}
	let xs = String.fromCharCode(x + 97);
	let ys = String.fromCharCode((8 - y) + 48);
	return xs + ys;
}

function InfoVal(s, key) {

	// Given some string like "info depth 8 seldepth 22 time 469 nodes 3918 score cp 46 hashfull 13 nps 8353 tbhits 0 multipv 1 pv d2d4 g8f6"
	// pull the value for the key out, e.g. in this example, key "nps" returns "8353" (as a string).
	//
	// Since Lc0's info strings often have the value ending in ")", we strip that out.

	if (typeof s !== "string" || typeof key !== "string") {
		return "";
	}

	let tokens = s.split(" ").filter(s => s !== "");

	for (let i = 0; i < tokens.length - 1; i++) {
		if (tokens[i] === key) {
			if (tokens[i + 1].endsWith(")")) {
				return tokens[i + 1].slice(0, -1);
			} else {
				return tokens[i + 1];
			}
		}
	}
	return "";
}

function InfoPV(s) {

	// Pull the PV out, assuming it's at the end of the string.

	if (typeof s !== "string") {
		return [];
	}

	let tokens = s.split(" ").filter(s => s !== "");

	for (let i = 0; i < tokens.length - 1; i++) {
		if (tokens[i] === "pv") {
			return tokens.slice(i + 1);
		}
	}
	return [];
}

function CompareArrays(a, b) {

	if (Array.isArray(a) === false || Array.isArray(b) === false) {
		return false;
	}

	if (a.length !== b.length) {
		return false;
	}

	for (let n = 0; n < a.length; n++) {
		if (a[n] !== b[n]) {
			return false;
		}
	}

	return true;
}

function ArrayIncludes(a, b) {

	if (Array.isArray(a) === false) {
		return false;
	}

	for (let item of a) {
		if (item === b) {
			return true;
		}
	}

	return false;
}

function ArrayStartsWith(a, b) {

	if (Array.isArray(a) === false || Array.isArray(b) === false) {
		return false;
	}

	if (a.length < b.length) {
		return false;
	}

	for (let n = 0; n < b.length; n++) {
		if (a[n] !== b[n]) {
			return false;
		}
	}

	return true;
}

function OppositeColour(s) {
	if (s === "w" || s === "W") return "b";
	if (s === "b" || s === "B") return "w";
	return "";
}

function ReplaceAll(s, search, replace) {		// FIXME? No type checks...
	return s.split(search).join(replace);
}

function SafeString(s) {
	if (typeof s !== "string") {
		return undefined;						// FIXME? Is this really the thing to do?
	}
	s = ReplaceAll(s, "&", "&amp;");			// This needs to be first of course.
	s = ReplaceAll(s, "<", "&lt;");
	s = ReplaceAll(s, ">", "&gt;");
	s = ReplaceAll(s, "'", "&apos;");
	s = ReplaceAll(s, "\"", "&quot;");
	return s;
}

function Log(s) {
	return;
}

function New2DArray(width, height) {

	let ret = [];

	for (let x = 0; x < width; x++) {
		ret.push([]);
		for (let y = 0; y < height; y++) {
			ret[x].push(null);
		}
	}

	return ret;
}

function CanvasCoords(x, y) {

	// Given the x, y coordinates on the board (a8 is 0, 0)
	// return an object with the canvas coordinates for
	// the square, and also the centre.
	//
	//      x1,y1--------
	//        |         |
	//        |  cx,cy  |
	//        |         |
	//        --------x2,y2

	let css = config.square_size;
	let x1 = x * css;
	let y1 = y * css;
	let x2 = x1 + css;
	let y2 = y1 + css;

	if (config.flip) {
		[x1, x2] = [(css * 8) - x2, (css * 8) - x1];
		[y1, y2] = [(css * 8) - y2, (css * 8) - y1];
	}

	let cx = x1 + css / 2;
	let cy = y1 + css / 2;

	return {x1, y1, x2, y2, cx, cy};
}

function EventPathString(event, prefix) {

	// Given an event with event.path like ["foo", "bar", "searchmove_e2e4", "whatever"]
	// return the string "e2e4", assuming the prefix matches. Else return null.

	let path = event.path || (event.composedPath && event.composedPath());

	if (!event || typeof prefix !== "string" || Array.isArray(path) === false) {
		return null;
	}

	for (let item of path) {
		if (typeof item.id === "string") {
			if (item.id.startsWith(prefix)) {
				return item.id.slice(prefix.length);
			}
		}
	}

	return null;
}

function EventPathN(event, prefix) {

	// As above, but returning a number, or null.

	let s = EventPathString(event, prefix);

	if (typeof s !== "string") {
		return null;
	}

	let n = parseInt(s, 10);

	if (Number.isNaN(n)) {
		return null;
	}

	return n;
}

function SwapElements(obj1, obj2) {

	// https://stackoverflow.com/questions/10716986/swap-2-html-elements-and-preserve-event-listeners-on-them

    var temp = document.createElement("div");
    obj1.parentNode.insertBefore(temp, obj1);
    obj2.parentNode.insertBefore(obj1, obj2);
    temp.parentNode.insertBefore(obj2, temp);
    temp.parentNode.removeChild(temp);
}

function NString(n) {

	if (typeof n !== "number") {
		return "?";
	}

	if (n < 1000) {
		return n.toString();
	}

	if (n < 100000) {
		return (n / 1000).toFixed(1) + "k";
	}

	if (n < 1000000) {
		return (n / 1000).toFixed(0) + "k";
	}

	if (n < 100000000) {
		return (n / 1000000).toFixed(1) + "M";
	}

	return (n / 1000000).toFixed(0) + "M";
}

function DateString(dt) {
	let y = dt.getFullYear();
	let m = dt.getMonth() + 1;
	let d = dt.getDate();
	let parts = [
		y.toString(),
		(m > 9 ? "" : "0") + m.toString(),
		(d > 9 ? "" : "0") + d.toString(),
	];
	return parts.join(".");
}

function QfromPawns(pawns) {

	// Note carefully: the arg is pawns not centipawns.

	if (typeof (pawns) !== "number") {
		return 0.5;
	}
	let winrate = 1 / (1 + Math.pow(10, -pawns / 4));
	return winrate * 2 - 1;
}

function Sign(n) {
	if (n < 0) return -1;
	if (n > 0) return 1;
	return 0;
}

function DurationString(ms) {

	let hours = Math.floor(ms / 3600000);
	ms -= hours * 3600000;

	let minutes = Math.floor(ms / 60000);
	ms -= minutes * 60000;

	let seconds = Math.floor(ms / 1000);

	if (hours > 0) {
		return `${hours}h ${minutes}m`;
	}

	if (minutes > 0) {
		return `${minutes}m ${seconds}s`;
	}

	return `${seconds}s`;
}

// The point of most of this is to make each Point represented by a single object so that
// naive equality checking works, i.e. Point(x, y) === Point(x, y) should be true. Since
// object comparisons in JS will be false unless they are the same object, we do all this...

function Point(a, b) {

	// We store the 64+1 point objects in the function object itself,
	// like static variables. On the first call, make them...

	if (Point.all_points === undefined) {

		Point.all_points = Object.create(null);
		for (let x = 0; x < 8; x++) {
			for (let y = 0; y < 8; y++) {
				let s = S(x, y);
				Point.all_points[s] = {x, y, s};
			}
		}

		Point.null_point = {x: -1, y: -1, s: "??"};
	}

	// Point("a8") or Point(0, 0) are both valid.

	let s;

	if (typeof a === "string") {		// Check if string, then check if not numbers...
		s = a;
	} else if (typeof a !== "number" || typeof b !== "number") {
		return Point.null_point;
	} else {
		s = S(a, b);
	}

	let p = Point.all_points[s];

	if (p === undefined) {
		return Point.null_point;
	}

	return p;
}

// Note: I rather regret now the existence of Point(null) - it means there's two
// different ways for a variable that usually holds a Point to be null - either
// having the actual null (or undefined) value, or the Point(null) value. Alas.

// All our positions have a prototype which contains the methods needed. This is much faster than
// creating each position with methods embedded in itself. Downside is, we have to use the "this"
// keyword. Also note that => functions break "this" in such an object.

const position_prototype = {

	move: function(s) {

		// s is something like "d1f3" or "e7e8q".
		// Assumes move is legal - all sorts of weird things can happen if this isn't so.

		// Basic sanity checks only:

		if (typeof s !== "string" || s.length < 4) {
			console.log("position_prototype.move called with arg", s);
			return this;
		}

		let [x1, y1] = XY(s.slice(0, 2));
		let [x2, y2] = XY(s.slice(2, 4));

		if (x1 < 0 || y1 < 0 || x1 > 7 || y1 > 7 || x2 < 0 || y2 < 0 || x2 > 7 || y2 > 7) {
			console.log("position_prototype.move called with arg", s);
			return this;
		}

		if (this.state[x1][y1] === "") {
			console.log("position_prototype.move called with empty source, arg was", s);
			return this;
		}

		let ret = this.copy();

		let promotion_char = s.length > 4 ? s[4].toLowerCase() : "q";
		
		let white_flag = this.is_white(Point(x1, y1));
		let pawn_flag = "Pp".includes(ret.state[x1][y1]);
		let capture_flag = ret.state[x2][y2] !== "";

		if (pawn_flag && x1 !== x2) {		// Make sure capture_flag is set even for enpassant captures
			capture_flag = true;
		}

		// Update castling info...

		if (ret.state[x1][y1] === "K") {
			ret.castling = ReplaceAll(ret.castling, "K", "");
			ret.castling = ReplaceAll(ret.castling, "Q", "");
		}

		if (ret.state[x1][y1] === "k") {
			ret.castling = ReplaceAll(ret.castling, "k", "");
			ret.castling = ReplaceAll(ret.castling, "q", "");
		}

		if ((x1 == 0 && y1 == 0) || (x2 == 0 && y2 == 0)) {
			ret.castling = ReplaceAll(ret.castling, "q", "");
		}

		if ((x1 == 7 && y1 == 0) || (x2 == 7 && y2 == 0)) {
			ret.castling = ReplaceAll(ret.castling, "k", "");
		}

		if ((x1 == 0 && y1 == 7) || (x2 == 0 && y2 == 7)) {
			ret.castling = ReplaceAll(ret.castling, "Q", "");
		}

		if ((x1 == 7 && y1 == 7) || (x2 == 7 && y2 == 7)) {
			ret.castling = ReplaceAll(ret.castling, "K", "");
		}

		// Update halfmove and fullmove...

		if (white_flag === false) {
			ret.fullmove++;
		}

		if (pawn_flag || capture_flag) {
			ret.halfmove = 0;
		} else {
			ret.halfmove++;
		}

		// Handle the rook moves of castling...

		if (ret.state[x1][y1] === "K" || ret.state[x1][y1] === "k") {

			if (s === "e1g1") {
				ret.state[5][7] = "R";
				ret.state[7][7] = "";
			}

			if (s === "e1c1") {
				ret.state[3][7] = "R";
				ret.state[0][7] = "";
			}

			if (s === "e8g8") {
				ret.state[5][0] = "r";
				ret.state[7][0] = "";
			}

			if (s === "e8c8") {
				ret.state[3][0] = "r";
				ret.state[0][0] = "";
			}
		}

		// Handle enpassant captures...

		if (pawn_flag && capture_flag && ret.state[x2][y2] === "") {
			ret.state[x2][y1] = "";
		}

		// Set enpassant square...

		ret.enpassant = Point(null);

		if (pawn_flag && y1 === 6 && y2 === 4) {
			ret.enpassant = Point(x1, 5);
		}

		if (pawn_flag && y1 === 1 && y2 === 3) {
			ret.enpassant = Point(x1, 2);
		}

		// Actually make the move...

		ret.state[x2][y2] = ret.state[x1][y1];
		ret.state[x1][y1] = "";

		// Handle promotions...

		if (y2 === 0 && pawn_flag) {
			ret.state[x2][y2] = promotion_char.toUpperCase();
		}

		if (y2 === 7 && pawn_flag) {
			ret.state[x2][y2] = promotion_char;		// Always lowercase.
		}

		// Swap who the current player is...

		ret.active = white_flag ? "b" : "w";

		return ret;
	},

	illegal: function(s) {

		// Returns "" if the move is legal, otherwise returns the reason it isn't.

		if (typeof s !== "string") {
			return "not a string";
		}

		let [x1, y1] = XY(s.slice(0, 2));
		let [x2, y2] = XY(s.slice(2, 4));

		if (x1 < 0 || y1 < 0 || x1 > 7 || y1 > 7 || x2 < 0 || y2 < 0 || x2 > 7 || y2 > 7) {
			return "off board";
		}

		if (this.active === "w" && this.is_white(Point(x1, y1)) === false) {
			return "wrong colour source";
		}

		if (this.active === "b" && this.is_black(Point(x1, y1)) === false) {
			return "wrong colour source";
		}

		if (this.same_colour(Point(x1, y1), Point(x2, y2))) {
			return "source and destination have same colour";
		}

		if ("Nn".includes(this.state[x1][y1])) {
			if (Math.abs(x2 - x1) + Math.abs(y2 - y1) !== 3) {
				return "illegal knight movement";
			}
			if (Math.abs(x2 - x1) === 0 || Math.abs(y2 - y1) === 0) {
				return "illegal knight movement";
			}
		}

		if ("Bb".includes(this.state[x1][y1])) {
			if (Math.abs(x2 - x1) !== Math.abs(y2 - y1)) {
				return "illegal bishop movement";
			}
		}

		if ("Rr".includes(this.state[x1][y1])) {
			if (Math.abs(x2 - x1) > 0 && Math.abs(y2 - y1) > 0) {
				return "illegal rook movement";
			}
		}

		if ("Qq".includes(this.state[x1][y1])) {
			if (Math.abs(x2 - x1) !== Math.abs(y2 - y1)) {
				if (Math.abs(x2 - x1) > 0 && Math.abs(y2 - y1) > 0) {
					return "illegal queen movement";
				}
			}
		}

		// Pawns...

		if ("Pp".includes(this.state[x1][y1])) {

			if (Math.abs(x2 - x1) === 0) {
				if (this.state[x2][y2] !== "") {
					return "pawn cannot capture forwards";
				}
			}

			if (Math.abs(x2 - x1) > 1) {
				return "pawn cannot move that far sideways";
			}

			if (Math.abs(x2 - x1) === 1) {

				if (this.state[x2][y2] === "") {
					if (this.enpassant !== Point(x2, y2)) {
						return "pawn cannot capture thin air";
					}
				}

				if (Math.abs(y2 - y1) !== 1) {
					return "pawn must move 1 forward when capturing";
				}
			}

			if (this.state[x1][y1] === "P") {
				if (y1 !== 6) {
					if (y2 - y1 !== -1) {
						return "pawn must move forwards 1";
					}
				} else {
					if (y2 - y1 !== -1 && y2 - y1 !== -2) {
						return "pawn must move forwards 1 or 2";
					}
				}
			}

			if (this.state[x1][y1] === "p") {
				if (y1 !== 1) {
					if (y2 - y1 !== 1) {
						return "pawn must move forwards 1";
					}
				} else {
					if (y2 - y1 !== 1 && y2 - y1 !== 2) {
						return "pawn must move forwards 1 or 2";
					}
				}
			}
		}

		// Kings...

		if ("Kk".includes(this.state[x1][y1])) {

			if (Math.abs(y2 - y1) > 1) {
				return "illegal king movement";
			}

			if (Math.abs(x2 - x1) > 1) {

				// This should be an attempt to castle...

				if (s !== "e1g1" && s !== "e1c1" && s !== "e8g8" && s !== "e8c8") {
					return "illegal king movement";
				}

				// So it is an attempt to castle. But is it allowed?

				if (s === "e1g1" && this.castling.includes("K") === false) {
					return "White lost the right to castle kingside";
				}

				if (s === "e1c1" && this.castling.includes("Q") === false) {
					return "White lost the right to castle queenside";
				}

				if (s === "e8g8" && this.castling.includes("k") === false) {
					return "Black lost the right to castle kingside";
				}

				if (s === "e8c8" && this.castling.includes("q") === false) {
					return "White lost the right to castle queenside";
				}

				// For queenside castling, check that the rook isn't blocked by a piece on the B file...

				if (x2 === 2 && this.piece(Point(1, y2)) !== "") {
					return "queenside castling blocked on B-file";
				}

				// Check that king source square and the pass-through square aren't under attack.
				// Destination will be handled by the general in-check test later.
				
				if (this.attacked(Point(x1, y1), this.active)) {
					return "cannot castle under check";
				}

				if (this.attacked(Point((x1 + x2) / 2, y1), this.active)) {
					return "cannot castle through check";
				}
			}
		}

		// Check for blockers (pieces between source and dest).
		// K and k are included to spot castling blockers.

		if ("KQRBPkqrbp".includes(this.state[x1][y1])) {
			if (this.los(x1, y1, x2, y2) === false) {
				return "movement blocked";
			}
		}

		// Check promotion and string lengths...
		// We DO NOT tolerate missing promotion characters.

		if ((y1 === 1 && this.state[x1][y1] === "P") || (y1 === 6 && this.state[x1][y1] === "p")) {

			if (s.length !== 5) {
				return "bad string length";
			}

			let promotion = s[4];

			if (promotion !== "q" && promotion !== "r" && promotion !== "b" && promotion !== "n") {
				return "move requires a valid promotion piece";
			}

		} else {

			if (s.length !== 4) {
				return "bad string length";
			}

		}

		// Check for check...

		let tmp = this.move(s);

		for (let x = 0; x < 8; x++) {
			for (let y = 0; y < 8; y++) {
				if (tmp.state[x][y] === "K" && this.active === "w") {
					if (tmp.attacked(Point(x, y), this.active)) {
						return "king in check";
					}
				}
				if (tmp.state[x][y] === "k" && this.active === "b") {
					if (tmp.attacked(Point(x, y), this.active)) {
						return "king in check";
					}
				}
			}
		}

		return "";
	},

	sequence_illegal: function(moves) {

		let pos = this;

		for (let s of moves) {
			let reason = pos.illegal(s);
			if (reason !== "") {
				return `${s} - ${reason}`;
			}
			pos = pos.move(s);
		}

		return "";
	},

	los: function(x1, y1, x2, y2) {		// Returns false if there is no "line of sight" between the 2 points.

		// Check the line is straight....

		if (Math.abs(x2 - x1) > 0 && Math.abs(y2 - y1) > 0) {
			if (Math.abs(x2 - x1) !== Math.abs(y2 - y1)) {
				return false;
			}
		}

		let step_x;
		let step_y;

		if (x1 === x2) step_x = 0;
		if (x1 < x2) step_x = 1;
		if (x1 > x2) step_x = -1;

		if (y1 === y2) step_y = 0;
		if (y1 < y2) step_y = 1;
		if (y1 > y2) step_y = -1;

		let x = x1;
		let y = y1;

		while (true) {

			x += step_x;
			y += step_y;

			if (x === x2 && y === y2) {
				return true;
			}

			if (this.state[x][y] !== "") {
				return false;
			}
		}
	},

	attacked: function(target, my_colour) {

		if (!my_colour) {
			throw "attacked(): no colour given";
		}

		if (!target || target === Point(null)) {
			return false;
		}

		// Attacks along the lines...

		for (let step_x = -1; step_x <= 1; step_x++) {

			for (let step_y = -1; step_y <= 1; step_y++) {

				if (step_x === 0 && step_y === 0) continue;

				if (this.line_attack(target, step_x, step_y, my_colour)) {
					return true;
				}
			}
		}

		// Knights...

		for (let d of [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]]) {

			let x = target.x + d[0];
			let y = target.y + d[1];

			if (x < 0 || x > 7 || y < 0 || y > 7) continue;

			if (this.state[x][y] === "") continue;		// Necessary, to prevent "Nn".includes() having false positives
			if ("Nn".includes(this.state[x][y])) {
				if (this.colour(Point(x, y)) === my_colour) continue;
				return true;
			}
		}

		return false;
	},

	line_attack: function(target, step_x, step_y, my_colour) {

		// Is the target square under attack via the line specified by step_x and step_y (which are both -1, 0, or 1) ?

		if (!my_colour) {
			throw "line_attack(): no colour given";
		}

		if (!target || target === Point(null)) {
			return false;
		}

		if (step_x === 0 && step_y === 0) {
			return false;
		}

		let x = target.x;
		let y = target.y;

		let ranged_attackers = "QqRr";					// Ranged attackers that can go in a cardinal direction.
		if (step_x !== 0 && step_y !== 0) {
			ranged_attackers = "QqBb";					// Ranged attackers that can go in a diagonal direction.
		}

		let iteration = 0;

		while (true) {

			iteration++;

			x += step_x;
			y += step_y;

			if (x < 0 || x > 7 || y < 0 || y > 7) {
				return false;
			}

			if (this.state[x][y] === "") {
				continue;
			}

			// So there's something here. Must return now.

			if (this.colour(Point(x, y)) === my_colour) {
				return false;
			}

			// We now know the piece is hostile. This allows us to mostly not care
			// about distinctions between "Q" and "q", "R" and "r", etc.

			// Is it one of the ranged attacker types?

			if (ranged_attackers.includes(this.state[x][y])) {
				return true;
			}

			// Pawns and kings are special cases (attacking iff it's the first iteration)

			if (iteration === 1) {

				if ("Kk".includes(this.state[x][y])) {
					return true;
				}

				if (Math.abs(step_x) === 1) {

					if (this.state[x][y] === "p" && step_y === -1) {	// Black pawn in attacking position
						return true;
					}

					if (this.state[x][y] === "P" && step_y === 1) {		// White pawn in attacking position
						return true;
					}
				}
			}

			return false;
		}
	},

	find: function(piece, startx, starty, endx, endy) {

		// Find all pieces of the specified type (colour-specific).
		// Returned as a list of points.

		for (let val of [startx, starty, endx, endy]) {
			if (typeof val !== "number" || val < 0 || val > 7) {
				startx = 0;
				starty = 0;
				endx = 7;
				endy = 7;
				break;
			}
		}

		let ret = [];

		for (let x = startx; x <= endx; x++) {
			for (let y = starty; y <= endy; y++) {
				if (this.state[x][y] === piece) {
					ret.push(Point(x, y));
				}
			}
		}

		return ret;
	},

	parse_pgn: function(s) {		// Returns a move and an error message.

		// Delete things we don't need...

		s = ReplaceAll(s, "x", "");
		s = ReplaceAll(s, "+", "");
		s = ReplaceAll(s, "#", "");
		s = ReplaceAll(s, "!", "");
		s = ReplaceAll(s, "?", "");

		// If the string contains any dots it'll be something like "1.e4" or "1...e4"

		let lio = s.lastIndexOf(".");
		if (lio !== -1) {
			s = s.slice(lio + 1);
		}

		// Fix castling with zeroes...

		s = ReplaceAll(s, "0-0", "O-O");
		s = ReplaceAll(s, "0-0-0", "O-O-O");

		if (s.toUpperCase() === "O-O") {
			if (this.active === "w") {
				if (this.state[4][7] === "K" && this.illegal("e1g1") === "") {
					return ["e1g1", ""];
				} else {
					return ["", "illegal castling"];
				}
			} else {
				if (this.state[4][0] === "k" && this.illegal("e8g8") === "") {
					return ["e8g8", ""];
				} else {
					return ["", "illegal castling"];
				}
			}
		}

		if (s.toUpperCase() === "O-O-O") {
			if (this.active === "w") {
				if (this.state[4][7] === "K" && this.illegal("e1c1") === "") {
					return ["e1c1", ""];
				} else {
					return ["", "illegal castling"];
				}
			} else {
				if (this.state[4][0] === "k" && this.illegal("e8c8") === "") {
					return ["e8c8", ""];
				} else {
					return ["", "illegal castling"];
				}
			}
		}

		// Just in case, delete any "-" characters (after handling castling, of course)...

		s = ReplaceAll(s, "-", "");

		// Save promotion string, if any, then delete it from s...

		let promotion = "";

		if (s[s.length - 2] === "=") {
			promotion = s[s.length - 1].toLowerCase();
			s = s.slice(0, -2);
		}

		let piece;

		// If the piece isn't specified (with an uppercase letter) then it's a pawn move.
		// Let's add P to the start of the string to keep the string format consistent.

		if ("KQRBNP".includes(s[0]) === false) {
			s = "P" + s;
		}

		piece = s[0];

		if (this.active === "b") {
			piece = piece.toLowerCase();
		}

		// The last 2 characters specify the target point. We've removed all trailing
		// garbage that could interfere with this fact.

		let dest = Point(s.slice(s.length - 2, s.length));

		// Any characters between the piece and target should be disambiguators...

		let disambig = s.slice(1, -2);

		let startx = 0;
		let endx = 7;

		let starty = 0;
		let endy = 7;

		for (let c of Array.from(disambig)) {
			if (c >= "a" && c <= "h") {
				startx = c.charCodeAt(0) - 97;
				endx = startx;
			}
			if (c >= "1" && c <= "8") {
				starty = 7 - (c.charCodeAt(0) - 49);
				endy = starty;
			}
		}

		// If it's a pawn and hasn't been disambiguated then it is moving forwards...

		if (piece === "P" || piece === "p") {
			if (disambig.length === 0) {
				startx = dest.x;
				endx = dest.x;
			}
		}

		let sources = this.find(piece, startx, starty, endx, endy);

		if (sources.length === 0) {
			return ["", "piece not found"];
		}

		let possible_moves = [];

		for (let source of sources) {
			possible_moves.push(source.s + dest.s + promotion);
		}

		let valid_moves = [];

		for (let move of possible_moves) {
			if (this.illegal(move) === "") {
				valid_moves.push(move);
			}
		}

		if (valid_moves.length === 1) {
			return [valid_moves[0], ""];
		}

		if (valid_moves.length === 0) {
			return ["", "piece found but move illegal"];
		}

		if (valid_moves.length > 1) {
			return ["", `ambiguous moves: [${valid_moves}]`];
		}
	},

	piece: function(point) {
		if (!point || point === Point(null)) return "";
		return this.state[point.x][point.y];
	},

	is_white: function(point) {
		let piece = this.piece(point);
		if (piece === "") {
			return false;
		}
		return "KQRBNP".includes(piece);
	},

	is_black: function(point) {
		let piece = this.piece(point);
		if (piece === "") {
			return false;
		}
		return "kqrbnp".includes(piece);
	},

	is_empty: function(point) {
		return this.piece(point) === "";
	},

	colour: function(point) {
		if (this.is_white(point)) return "w";
		if (this.is_black(point)) return "b";
		return "";
	},

	same_colour: function(point1, point2) {
		return this.colour(point1) === this.colour(point2);
	},

	movegen: function() {

		// Super-crude brute-force, but it does work.
		// Probably best to never use this, but it might be useful in debugging.

		let moves = [];

		for (let x = 0; x < 8; x++) {
			for (let y = 0; y < 8; y++) {
				let source = Point(x, y);
				if (this.colour(source) !== this.active) {
					continue;
				}
				for (let i = 0; i < 8; i++) {
					for (let j = 0; j < 8; j++) {
						let dest = Point(i, j);
						let move = source.s + dest.s;
						if ((this.piece(source) === "P" && dest.y === 0) || (this.piece(source) === "p" && dest.y === 7)) {
							for (let c of "qrbn") {
								if (this.illegal(move + c) === "") {
									moves.push(move + c);
								}
							}
						}
						if (this.illegal(move) === "") {
							moves.push(move);
						}
					}
				}
			}
		}

		return moves;
	},

	nice_movegen: function() {
		return this.movegen().map(s => this.nice_string(s));
	},

	nice_string: function(s) {

		// Given some raw (but valid) UCI move string, return a nice human-readable
		// string for display in the browser window. This string should never be
		// examined by the caller, merely displayed.

		let source = Point(s.slice(0, 2));
		let dest = Point(s.slice(2, 4));

		if (source === Point(null) || dest === Point(null)) {
			return "??";
		}

		let piece = this.piece(source);

		if (piece === "") {
			return "??";
		}

		let check = "";
		let next_board = this.move(s);
		let opponent_king_char = this.active === "w" ? "k" : "K";
		let opponent_king_square = this.find(opponent_king_char)[0];	// Might be undefined on corrupt board...

		if (opponent_king_square && next_board.attacked(opponent_king_square, next_board.colour(opponent_king_square))) {
			check = "+";
		}

		if ("KkQqRrBbNn".includes(piece)) {

			if ("Kk".includes(piece)) {
				if (s === "e1g1" || s === "e8g8") {
					return `O-O${check}`;
				}
				if (s === "e1c1" || s === "e8c8") {
					return `O-O-O${check}`;
				}
			}

			// Would the move be ambiguous?
			// IMPORTANT: note that the actual move will not necessarily be valid_moves[0].

			let possible_sources = this.find(piece);
			let possible_moves = [];
			let valid_moves = [];

			for (let foo of possible_sources) {
				possible_moves.push(foo.s + dest.s);		// e.g. "g1f3" - note we are only dealing with pieces, so no worries about promotion
			}

			for (let move of possible_moves) {
				if (this.illegal(move) === "") {
					valid_moves.push(move);
				}
			}

			if (valid_moves.length > 2) {

				// Full disambiguation.

				if (this.piece(dest) === "") {
					return piece.toUpperCase() + source.s + dest.s + check;
				} else {
					return piece.toUpperCase() + source.s + "x" + dest.s + check;
				}
			}

			if (valid_moves.length === 2) {

				// Partial disambiguation.

				let source1 = Point(valid_moves[0].slice(0, 2));
				let source2 = Point(valid_moves[1].slice(0, 2));

				let disambiguator;

				if (source1.x === source2.x) {
					disambiguator = source.s[1];		// Note source (the true source), not source1
				} else {
					disambiguator = source.s[0];		// Note source (the true source), not source1
				}

				if (this.piece(dest) === "") {
					return piece.toUpperCase() + disambiguator + dest.s + check;
				} else {
					return piece.toUpperCase() + disambiguator + "x" + dest.s + check;
				}
			}

			// No disambiguation.

			if (this.piece(dest) === "") {
				return piece.toUpperCase() + dest.s + check;
			} else {
				return piece.toUpperCase() + "x" + dest.s + check;
			}
		}

		// So it's a pawn. Pawn moves are never ambiguous.

		let ret;

		if (source.x === dest.x) {
			ret = dest.s;
		} else {
			ret = source.s[0] + "x" + dest.s;
		}

		if (s.length > 4) {
			ret += "=";
			ret += s[4].toUpperCase();
		}

		ret += check;

		return ret;
	},

	next_number_string: function() {
		if (this.active === "w") {
			return `${this.fullmove}.`;
		} else {
			return `${this.fullmove}...`;
		}
	},

	fen: function() {

		let s = "";

		for (let y = 0; y < 8; y++) {

			let x = 0;
			let blanks = 0;

			while (true) {

				if (this.state[x][y] === "") {
					blanks++;
				} else {
					if (blanks > 0) {
						s += blanks.toString();
						blanks = 0;
					}
					s += this.state[x][y];
				}

				x++;

				if (x >= 8) {
					if (blanks > 0) {
						s += blanks.toString();
					}
					if (y < 7) {
						s += "/";
					}
					break;
				}
			}
		}

		let ep_string = this.enpassant === Point(null) ? "-" : this.enpassant.s;
		let castling_string = this.castling === "" ? "-" : this.castling;

		return s + ` ${this.active} ${castling_string} ${ep_string} ${this.halfmove} ${this.fullmove}`;
	},

	copy: function() {
		return NewPosition(this.state, this.active, this.castling, this.enpassant, this.halfmove, this.fullmove);
	},
};

function NewPosition(state = null, active = "w", castling = "", enpassant = null, halfmove = 0, fullmove = 1) {

	let p = Object.create(position_prototype);

	p.state = [];					// top-left is 0,0

	for (let x = 0; x < 8; x++) {
		p.state.push([]);
		for (let y = 0; y < 8; y++) {
			if (state) {
				p.state[x].push(state[x][y]);
			} else {
				p.state[x].push("");
			}
		}
	}

	p.active = active;
	p.castling = castling;
	
	if (enpassant) {
		p.enpassant = enpassant;
	} else {
		p.enpassant = Point(null);
	}

	p.halfmove = halfmove;
	p.fullmove = fullmove;

	return p;
}

function LoadFEN(fen) {

	let ret = NewPosition();

	fen = ReplaceAll(fen, "\t", " ");
	fen = ReplaceAll(fen, "\n", " ");
	fen = ReplaceAll(fen, "\r", " ");

	let tokens = fen.split(" ").filter(s => s !== "");

	if (tokens.length !== 6) {
		throw "Invalid FEN - token count";
	}

	let rows = tokens[0].split("/");

	if (rows.length !== 8) {
		throw "Invalid FEN - board row count";
	}

	for (let y = 0; y < 8; y++) {

		let chars = Array.from(rows[y]);

		let x = 0;

		for (let c of chars) {

			if (x > 7) {
				throw "Invalid FEN - row length";
			}

			if ("12345678".includes(c)) {
				x += parseInt(c, 10);
				continue;
			}

			if ("KkQqRrBbNnPp".includes(c)) {
				ret.state[x][y] = c;
				x++;
				continue;
			}

			throw "Invalid FEN - unknown piece";
		}

		if (x !== 8) {
			throw "Invalid FEN - row length";
		}
	}

	tokens[1] = tokens[1].toLowerCase();
	if (tokens[1] !== "w" && tokens[1] !== "b") {
		throw "Invalid FEN - active player";
	}
	ret.active = tokens[1];

	ret.castling = "";
	if (tokens[2].includes("K")) ret.castling += "K";
	if (tokens[2].includes("Q")) ret.castling += "Q";
	if (tokens[2].includes("k")) ret.castling += "k";
	if (tokens[2].includes("q")) ret.castling += "q";

	// Tolerate bad castling rights, but fix them...

	if (ret.castling.includes("K")) {
		if (ret.state[4][7] !== "K" || ret.state[7][7] !== "R") {
			ret.castling = ReplaceAll(ret.castling, "K", "");
		}
	}
	if (ret.castling.includes("Q")) {
		if (ret.state[4][7] !== "K" || ret.state[0][7] !== "R") {
			ret.castling = ReplaceAll(ret.castling, "Q", "");
		}
	}
	if (ret.castling.includes("k")) {
		if (ret.state[4][0] !== "k" || ret.state[7][0] !== "r") {
			ret.castling = ReplaceAll(ret.castling, "k", "");
		}
	}
	if (ret.castling.includes("q")) {
		if (ret.state[4][0] !== "k" || ret.state[0][0] !== "r") {
			ret.castling = ReplaceAll(ret.castling, "q", "");
		}
	}

	tokens[3] = tokens[3].toLowerCase();
	ret.enpassant = Point(tokens[3]);
	
	ret.halfmove = parseInt(tokens[4], 10);
	if (Number.isNaN(ret.halfmove)) {
		throw "Invalid FEN - halfmoves";
	}

	ret.fullmove = parseInt(tokens[5], 10);
	if (Number.isNaN(ret.fullmove)) {
		throw "Invalid FEN - fullmoves";
	}

	let white_kings = 0;
	let black_kings = 0;

	for (let x = 0; x < 8; x++) {
		for (let y = 0; y < 8; y++) {
			if (ret.state[x][y] === "K") white_kings++;
			if (ret.state[x][y] === "k") black_kings++;
		}
	}

	if (white_kings !== 1 || black_kings !== 1) {
		throw "Invalid FEN - number of kings";
	}

	let opponent_king_char = ret.active === "w" ? "k" : "K";
	let opponent_king_square = ret.find(opponent_king_char)[0];

	if (ret.attacked(opponent_king_square, ret.colour(opponent_king_square))) {
		throw "Invalid FEN - non-mover's king in check";
	}

	return ret;
}

// EVERYTHING that changes the tree structure must increment the global counter  tree_version
// Currently this means:
//
//		- NewNode()
//		- promote_to_main_line()
//		- detach()

const node_prototype = {

	make_move: function(s, force_new_node) {

		// s must be exactly a legal move, including having promotion char iff needed (e.g. e2e1q)

		if (!force_new_node) {
			for (let child of this.children) {
				if (child.move === s) {
					return child;
				}
			}
		}

		let new_node = NewNode(this, s);
		this.children.push(new_node);

		return new_node;
	},

	history: function() {

		let moves = [];
		let node = this;

		while (node.move) {
			moves.push(node.move);
			node = node.parent;
		}

		moves.reverse();
		return moves;
	},

	future_history: function() {
		return this.get_end().history();
	},

	get_root: function() {

		let node = this;

		while (node.parent) {
			node = node.parent;
		}

		return node;
	},

	get_end: function() {

		let node = this;

		while (node.children.length > 0) {
			node = node.children[0];
		}

		return node;
	},

	get_board: function() {

		// Note that in various places elsewhere we assume that we can compare boards by
		// naive identity checking, which means this needs to always return the same object
		// for the same node, meaning that caching the position is unavoidable.

		if (this.__position) {
			return this.__position;
		}

		if (!this.parent) {
			throw "get_board(): no __position and no parent";
		}

		let node_line = [];
		let foo = this;

		while (!foo.__position) {
			node_line.push(foo);
			foo = foo.parent;
		}
		node_line.reverse();

		let board = node_line[0].parent.__position;

		for (let node of node_line) {
			board = board.move(node.move);
			// node.__position = board;
		}

		this.__position = board;
		return this.__position;
	},

	promote_to_main_line: function() {

		let node = this;

		while (node.parent) {
			if (node.parent.children[0] !== node) {
				for (let n = 1; n < node.parent.children.length; n++) {
					if (node.parent.children[n] === node) {
						node.parent.children[n] = node.parent.children[0];
						node.parent.children[0] = node;
						break;
					}
				}
			}
			node = node.parent;
		}

		tree_version++;
	},

	nice_move: function() {
		if (!this.move || !this.parent) {
			return "??";
		}

		return this.parent.get_board().nice_string(this.move);
	},

	token: function() {

		// The complete token when writing the move, including number string if necessary,
		// which depends on position within variations etc...

		if (!this.move || !this.parent) {
			return "";
		}

		let need_number_string = false;

		if (this.parent.get_board().active === "w") need_number_string = true;
		if (this.parent.children[0] !== this) need_number_string = true;

		// In theory we should also write the number if the parent had siblings. Meh.

		let s = "";

		if (need_number_string) {
			s += this.parent.get_board().next_number_string() + " ";
		}
		
		s += this.nice_move();

		if (this.stats) {
			s += " {" + this.stats + "}";
		}

		return s;
	},

	detach: function() {

		// Returns the node that the renderer should point to,
		// which is the parent unless the call is a bad one.

		let parent = this.parent;
		if (!parent) return this;		// Fail

		let new_list_for_parent = [];

		for (let c of parent.children) {
			if (c !== this) {
				new_list_for_parent.push(c);
			}
		}

		parent.children = new_list_for_parent;
		this.parent = null;
		tree_version++;
		DestroyTree(this);
		return parent;
	}
};

function NewNode(parent, move) {		// Args are null for root only.

	let node = Object.create(node_prototype);

	node.__position = null;
	node.parent = parent;
	node.move = move;					// Think of this as the move that led to the position associated with node.
	node.children = [];

	tree_version++;
	return node;
}

function NewTree(startpos) {			// Arg is expected to be a position object, not a FEN.
	
	if (!startpos) {
		startpos = LoadFEN("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
	}

	let root = NewNode(null, null);
	root.__position = startpos;

	root.tags = Object.create(null);	// Only root gets these. Get overwritten by the PGN loader.
	root.tags.Event = "Nibbler Line";
	root.tags.Site = "The fevered dreams of a neural net";
	root.tags.Date = DateString(new Date());
	root.tags.Round = "1";
	root.tags.White = "White";
	root.tags.Black = "Black";
	root.tags.Result = "*";

	return root;
}

// On the theory that it might help the garbage collector, we can
// destroy trees when we're done with them. Perhaps this is totally
// unnecessary. I've seen it matter in Python.
//
// This does mean it's dangerous to ever store references to nodes
// and expect their get_board() method to always work. At the time
// of writing, we store no such references (not counting the
// reference the renderer has to its current node).

function DestroyTree(node) {
	__destroy_tree(node.get_root());
}

function __destroy_tree(node) {

	while (node.children.length === 1) {
		node.parent = null;
		node.__position = null;
		node.move = null;
		let child = node.children[0];
		node.children = null;
		node = child;
	}

	node.parent = null;
	node.__position = null;
	node.move = null;

	for (let child of node.children) {
		__destroy_tree(child);
	}

	node.children = null;
	return;
}

function split_buffer(buf) {

	// Split a binary buffer into an array of binary buffers corresponding to lines.

	let lines = [];

	let push = (arr) => {
		if (arr.length > 0 && arr[arr.length - 1] === 13) {		// Discard \r
			lines.push(Buffer.from(arr.slice(0, -1)));
		} else {
			lines.push(Buffer.from(arr));
		}
	};

	let a = 0;
	let b;

	for (b = 0; b < buf.length; b++) {
		let ch = buf[b];
		if (ch === 10) {					// Split on \n
			let line = buf.slice(a, b);
			push(line);
			a = b + 1;
		}
	}

	if (a !== b) {		// We haven't added the last line before EOF.
		let line = buf.slice(a, b);
		push(line);
	}

	return lines;
}

function new_byte_pusher(size) {

	if (!size || size <= 0) {
		size = 16;
	}

	// I bet Node has something like this, but I didn't read the docs.

	return {

		storage: new Uint8Array(size),
		length: 0,							// Both the length and also the next index to write to.

		push: function(c) {
			if (this.length >= this.storage.length) {
				let new_storage = new Uint8Array(this.storage.length * 2);
				for (let n = 0; n < this.storage.length; n++) {
					new_storage[n] = this.storage[n];
				}
				this.storage = new_storage;
			}
			this.storage[this.length] = c;
			this.length++;
		},

		bytes: function() {
			return this.storage.slice(0, this.length);
		},

		string: function() {
			return decoder.decode(this.bytes());
		}
	};
}

// -------------------------------------------------------------------------

function new_pgn_record() {
	return {
		tags: Object.create(null),
		movebufs: []
	};
}

function PreParsePGN(buf) {

	// Returns an array of pgn_record objects which have
	//		- a tags object
	//		- a movebuf list which contains the movetext lines for that game, as binary buffers.

	let games = [new_pgn_record()];
	let lines = split_buffer(buf);

	for (let rawline of lines) {

		if (rawline.length === 0) {
			continue;
		}

		if (rawline[0] === 37) {			// Percent % sign is a special comment type.
			continue;
		}

		let tagline = "";

		if (rawline[0] === 91) {
			let s = decoder.decode(rawline).trim();
			if (s.endsWith(`"]`)) {
				tagline = s;
			}
		}

		if (tagline !== "") {

			if (games[games.length - 1].movebufs.length > 0) {
				// We have movetext already, so this must be a new game. Start it.
				games.push(new_pgn_record());
			}

			// Parse the tag line...

			tagline = tagline.slice(1, -1);								// So now it's like:		Foo "bar etc"

			let quote_i = tagline.indexOf(`"`);

			if (quote_i === -1) {
				continue;
			}

			let key = tagline.slice(0, quote_i).trim();
			let value = tagline.slice(quote_i + 1).trim();

			if (value.endsWith(`"`)) {
				value = value.slice(0, -1);
			}

			games[games.length - 1].tags[key] = SafeString(value);		// Escape evil characters. IMPORTANT!

		} else {

			games[games.length - 1].movebufs.push(rawline);

		}
	}

	return games;
}

function LoadPGNRecord(o) {

	let startpos;

	if (o.tags.FEN) {							// && o.tags.SetUp === "1"
		startpos = LoadFEN(o.tags.FEN);
	} else {
		startpos = LoadFEN("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
	}

	let root = NewTree(startpos);
	let node = root;

	let inside_brace = false;			// {} are comments. Braces do not nest.

	let callstack = [];					// When a parenthesis "(" opens, we record the node to "return" to later, on the "callstack".

	let token = new_byte_pusher();

	let finished = false;

	for (let rawline of o.movebufs) {

		if (rawline.length === 0) {
			continue;
		}

		if (rawline[0] === 37) {		// Percent % sign is a special comment type.
			continue;
		}

		for (let i = 0; i < rawline.length; i++) {

			// Note that, when adding characters to our current token, we peek forwards
			// to check if it's the end of the token. Therefore, it's safe for these
			// special characters to fire a continue immediately.

			let c = rawline[i];

			if (c === 123) {									// The opening brace { for a comment
				inside_brace = true;
				continue;
			}

			if (inside_brace) {
				if (c === 125) {								// The closing brace }
					inside_brace = false;
				}
				continue;
			}

			if (c === 40) {										// The opening parenthesis (
				callstack.push(node);
				node = node.parent;								// Unplay the last move.
				continue;
			}

			if (c === 41) {										// The closing parenthesis )
				node = callstack[callstack.length - 1];
				callstack = callstack.slice(0, -1);
				continue;
			}

			// So, we are not in a brace nor a parenthesis...

			token.push(c);

			// It the current token complete?

			let peek = rawline[i + 1];

			if (
			peek === undefined		||			// end of line
			peek <= 32				||			// whitespace
			peek === 40				||			// (
			peek === 41				||			// )
			peek === 46				||			// .
			peek === 123) {						// {

				let initial_s = token.string();
				let s = initial_s.trim();

				token = new_byte_pusher();			// For the next round.

				// Parse s.

				if (s === "" || s.endsWith(".") || s.startsWith("$") || peek === 46) {
					// Useless token.
					continue;
				}

				if (s === "1/2-1/2" || s === "1-0" || s === "0-1" || s === "*") {
					finished = true;
					break;
				}

				// Probably an actual move...

				let [move, error] = node.get_board().parse_pgn(s);

				if (error !== "") {
					throw `"${s}" -- ${error}`;
				}

				node = node.make_move(move, true);
			}
		}

		if (finished) {
			break;
		}
	}

	// Save all tags into the root.

	if (!root.tags) {
		root.tags = Object.create(null);
	}
	for (let key of Object.keys(o.tags)) {
		root.tags[key] = o.tags[key];
	}

	return root;
}

// -------------------------------------------------------------------------

function SavePGN(filename, node) {
	let s = make_pgn_string(node);
	fs.writeFileSync(filename, s);
}

function PGNToClipboard(node) {
	let s = make_pgn_string(node);
	clipboard.writeText(s);
}

function make_pgn_string(node) {

	let root = node.get_root();
	let start_fen = root.get_board().fen();

	let tags = [];

	for (let t of ["Event", "Site", "Date", "Round", "White", "Black", "Result"]) {
		if (root.tags && root.tags[t]) {
			tags.push(`[${t} "${root.tags[t]}"]`);
		} else {
			tags.push(`[${t} "Not present (this is a Nibbler bug, please report)"]`);
		}
	}

	if (start_fen !== "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1") {
		tags.push(`[FEN "${start_fen}"]`);
		tags.push(`[SetUp "1"]`);
	}

	let movetext = make_movetext(root);
	let final = tags.join("\n") + "\n\n" + movetext + "\n";
	return final;
}

function make_movetext(node) {

	let root = node.get_root();
	let connector = new_string_node_connector();
	write_tree(root, connector, false, true);

	if (root.tags && root.tags.Result) {
		connector.push(root.tags.Result, null);
	} else {
		connector.push("*", null);
	}

	// Now it's all about wrapping to 80 chars...

	let lines = [];
	let line = "";

	for (let token of connector.tokens) {
		if (line.length + token.length > 79) {
			lines.push(line);
			line = token;
		} else {
			if (line.length > 0) {
				line += " ";
			}
			line += token;
		}
	}
	if (line !== "") {
		lines.push(line);
	}

	return lines.join("\n");
}

// -------------------------------------------------------------------------
// This section was invented for the window's move_list, but incidentally
// also produces valid PGN.

function TokenNodeConnections(node) {
	let connector = new_string_node_connector();
	write_tree(node.get_root(), connector, false, true);
	return connector;
}

function new_string_node_connector() {

	// Object will contain the tokens of a PGN string, plus what
	// node (possibly null) we should go to if they're clicked on.

	return {
		tokens: [],
		nodes: [],
		length: 0,
		push: function(token, node) {		// node can be null, i.e. no node matches this text
			this.tokens.push(token);
			this.nodes.push(node);
			this.length++;
		}
	};
}

function write_tree(node, connector, skip_self_flag, force_number_string) {

	// Create the connector object - it has a list of tokens
	// and a corresponding list of nodes/null.

	// Write this node itself...

	if (node.parent && !skip_self_flag) {
		connector.push(node.token(), node);
	}

	// Write descendents as long as there's no branching,
	// or return if we reach a node with no children.

	while (node.children.length === 1) {
		node = node.children[0];
		connector.push(node.token(), node);
	}

	if (node.children.length === 0) {
		return;
	}

	// So multiple child nodes exist...

	let main_child = node.children[0];
	connector.push(main_child.token(), main_child);

	for (let child of node.children.slice(1)) {
		connector.push("(", null);
		write_tree(child, connector, false, true);
		connector.push(")", null);
	}

	write_tree(main_child, connector, true, false);
}

// In an ideal world, the inherent tree structure in the Chess record and the
// inherent tree structure in the DOM would relate to each other in such a way
// that inserting a new move, or highlighting a new node, etc, would have an
// obviously corresponding set of operations that had to occur in the DOM. Hmm.

function get_movelist_highlight() {
	let elements = document.getElementsByClassName("movelist_highlight_blue");
	if (elements && elements.length > 0) {
		return elements[0];
	}
	elements = document.getElementsByClassName("movelist_highlight_yellow");
	if (elements && elements.length > 0) {
		return elements[0];
	}
	return null;
}

function fix_scrollbar_position(node) {
	let highlight = get_movelist_highlight();
	if (highlight) {
		let top = highlight.offsetTop - movelist.offsetTop;
		if (top < movelist.scrollTop) {
			movelist.scrollTop = top;
		}
		let bottom = top + highlight.offsetHeight;
		if (bottom > movelist.scrollTop + movelist.offsetHeight) {
			movelist.scrollTop = bottom - movelist.offsetHeight;
		}
	} else {
		movelist.scrollTop = 0;
	}
}

function NewMovelistHander() {

	// Note that this stores almost no info about the tree. It's its own
	// object for cleanliness purposes rather than because it has some
	// huge amount of state to store.
	//
	// Only one of these objects is ever made.

	let handler = Object.create(null);

	handler.connections = null;
	handler.connections_version = null;
	handler.line_end = null;

	handler.draw = function(node) {

		// Note that the node passed as an argument is the currently displayed node.
		// This info is used to decide what to highlight.

		if (!node) {
			return;
		}

		let end = node.get_end();

		if (end === this.line_end && this.connections && this.connections_version === tree_version) {
			this.draw_lazy(node);
		} else {
			this.draw_hard(node);
		}

		fix_scrollbar_position();
	};

	handler.draw_lazy = function(node) {

		// The tree hasn't changed, nor has the end node of the displayed line. Therefore very little needs
		// to be done, except the highlight class needs to be applied to a different element. One thing this
		// fails to do is update stats drawn in the movelist.

		if (!node || !this.connections) {
			return;
		}

		let span = get_movelist_highlight();
		let highlight_class = span ? span.className : "movelist_highlight_blue";	// If nothing was highlighted, old position was root.

		if (span) {
			span.className = "white";		// This is always correct, it's never gray.
		}

		// Find the n of the new highlight...

		let n = null;

		for (let i = 0; i < this.connections.length; i++) {
			if (this.connections.nodes[i] === node) {
				n = i;
				break;
			}
		}

		if (typeof n === "number") {
			let span = document.getElementById(`movelist_${n}`);
			span.className = highlight_class;
		}
	};

	handler.draw_hard = function(node) {

		if (!node) {
			return;
		}

		// Flag nodes that are on the current line (including into the future).
		// We'll undo this damage to the tree in a bit.

		this.line_end = node.get_end();

		let foo = this.line_end;
		while (foo) {
			foo.current_line = true;
			foo = foo.parent;
		}

		// We'd also like to know if the current node is on the main line...

		let on_mainline = false;

		foo = node.get_root().get_end();
		while (foo) {
			if (foo === node) {
				on_mainline = true;
				break;
			}
			foo = foo.parent;
		}

		//

		if (!this.connections || this.connections_version !== tree_version) {
			this.connections = TokenNodeConnections(node);
			this.connections_version = tree_version;
		}

		let elements = [];		// Objects containing class and text.

		for (let n = 0; n < this.connections.length; n++) {

			// Each item in the connections must have a corresponding element
			// in our elements list. The indices must match.

			let s = this.connections.tokens[n];

			let next_s = this.connections.tokens[n + 1];		// possibly undefined
			let connode = this.connections.nodes[n];			// possibly null

			let space = (s === "(" || next_s === ")") ? "" : " ";

			let element = {
				text: `${s}${space}`
			};

			if (connode === node) {
				element.class = on_mainline ? "movelist_highlight_blue" : "movelist_highlight_yellow";
			} else if (connode && connode.current_line) {
				element.class = "white";
			} else {
				element.class = "gray";
			}

			elements.push(element);
		}

		// Generate the new innerHTML for the movelist <p></p>

		let new_inner_parts = [];

		for (let n = 0; n < elements.length; n++) {
			let part = `<span id="movelist_${n}" class="${elements[n].class}">${elements[n].text}</span>`;
			new_inner_parts.push(part);
		}

		movelist.innerHTML = new_inner_parts.join("");	// Setting innerHTML is performant. Direct DOM manipulation is worse, somehow.

		// Undo the damage to our tree...

		foo = this.line_end;
		while(foo) {
			delete foo.current_line;
			foo = foo.parent;
		}
	};

	handler.redraw_node = function(node) {

		// For when some node in the tree has had its stats changed and we want to redraw just it.

		if (!this.connections || !node) {
			return;
		}

		for (let n = 0; n < this.connections.length; n++) {
			if (this.connections.nodes[n] === node) {
				let span = document.getElementById(`movelist_${n}`);
				if (span) {
					let space = this.connections.tokens[n + 1] === ")" ? "" : " ";
					let text = `${node.token()}${space}`;
					span.innerHTML = text;
					break;
				}
			}
		}
	};

	handler.node_from_click = function(event) {

		let n = EventPathN(event, "movelist_");
		if (typeof n !== "number") {
			return null;
		}

		if (!this.connections || n < 0 || n >= this.connections.length) {
			return null;
		}

		let node = this.connections.nodes[n];

		if (!node) {
			return null;
		}

		return node;
	};
	
	return handler;
}

function NewInfoHandler() {

	let ih = Object.create(null);

	ih.table = Object.create(null);			// Map of move (e.g. "e2e4") --> info object.
	ih.board = null;
	ih.version = 0;							// Incremented on any change.
	ih.nodes = 0;							// Stat sent by engine.
	ih.nps = 0;								// Stat sent by engine.
	ih.time = 0;							// Stat sent by engine.

	ih.ever_received_info = false;
	ih.ever_received_q = false;
	ih.ever_received_multipv_2 = false;

	ih.stderr_log = "";

	ih.one_click_moves = New2DArray(8, 8);	// Array of possible one-click moves. Updated by draw_arrows().
	ih.info_clickers = [];					// Elements in the infobox. Updated by draw_infobox().

	ih.last_drawn_version = null;
	ih.last_drawn_highlight = null;
	ih.last_drawn_highlight_class = null;
	ih.last_drawn_searchmoves = [];

	ih.clear = function(board) {
		if (!board) {
			throw "ih.clear(): need board";
		}
		this.table = Object.create(null);
		this.board = board;
		this.version++;
		this.nodes = 0;
		this.nps = 0;
		this.time = 0;
	};

	ih.err_receive = function(s) {

		if (typeof s !== "string") {
			return;
		}

		if (this.stderr_log.length > 50000) {
			return;
		}

		if (s.includes("WARNING") || s.includes("error")) {
			this.stderr_log += `<span class="red">${s}</span><br>`;
		} else {
			this.stderr_log += `${s}<br>`;
		}
	};

	ih.receive = function(s, board) {

		if (typeof s !== "string" || !board) {
			return;
		}

		// We use the board to check legality (only of the first move in the PV,
		// later moves are checked if we ever try to use them.)

		if (this.board !== board) {
			console.log("ih.receive(): Received unexpected board.");
			return;
		}

		if (s.startsWith("info") && s.includes(" pv ")) {

			this.ever_received_info = true;
			this.version++;

			// info depth 13 seldepth 48 time 5603 nodes 67686 score cp 40 hashfull 204 nps 12080 tbhits 0 multipv 2
			// pv d2d4 g8f6 c2c4 e7e6 g2g3 f8b4 c1d2 b4e7 g1f3 e8g8 d1c2 a7a6 f1g2 b7b5 e1g1 c8b7 f1c1 b7e4 c2d1 b5c4 c1c4 a6a5 d2e1 h7h6 c4c1 d7d6

			let move = InfoVal(s, "pv");
			let move_info;

			if (this.table[move]) {						// We already have move info for this move.
				move_info = this.table[move];
			} else {									// We don't.
				if (board.illegal(move) !== "") {
					Log(`... Nibbler: invalid move received!: ${move}`);
					return;
				}
				move_info = new_info(board, move);
				this.table[move] = move_info;
			}

			move_info.version = this.version;

			let tmp;

			tmp = parseInt(InfoVal(s, "cp"), 10);		// Score in centipawns
			if (Number.isNaN(tmp) === false) {
				move_info.cp = tmp;
				if (this.ever_received_q === false) {
					move_info.q = QfromPawns(tmp / 100);
				}
				move_info.mate = 0;						// Engines will send one of cp or mate, so mate gets reset when receiving cp
			}

			tmp = parseInt(InfoVal(s, "mate"), 10);
			if (Number.isNaN(tmp) === false) {
				move_info.mate = tmp;
				if (tmp !== 0) {
					move_info.q = tmp > 0 ? 1 : -1;
					move_info.cp = tmp > 0 ? 12800 : -12800;
				}
			}

			tmp = parseInt(InfoVal(s, "multipv"), 10);	// Leela's ranking of the move, starting at 1
			if (Number.isNaN(tmp) === false) {
				move_info.multipv = tmp;
				if (tmp > 1) {
					this.ever_received_multipv_2 = true;
				}
			}

			tmp = parseInt(InfoVal(s, "nodes"), 10);
			if (Number.isNaN(tmp) === false) {
				this.nodes = tmp;
			}

			tmp = parseInt(InfoVal(s, "nps"), 10);
			if (Number.isNaN(tmp) === false) {
				this.nps = tmp;
			}

			tmp = parseInt(InfoVal(s, "time"), 10);
			if (Number.isNaN(tmp) === false) {
				this.time = tmp;
			}

			let new_pv = InfoPV(s);

			if (new_pv.length === 0) {
				new_pv = [move];
			}

			if (CompareArrays(new_pv, move_info.pv) === false) {
				move_info.nice_pv_cache = null;
				move_info.pv = new_pv;
			}

		} else if (s.startsWith("info string")) {

			this.ever_received_info = true;
			this.version++;

			// info string d2d4  (293 ) N:   12845 (+121) (P: 20.10%) (Q:  0.09001) (D:  0.000) (U: 0.02410) (Q+U:  0.11411) (V:  0.1006)

			let move = InfoVal(s, "string");
			let move_info;

			if (this.table[move]) {						// We already have move info for this move.
				move_info = this.table[move];
			} else {									// We don't.
				if (board.illegal(move) !== "") {
					Log(`... Nibbler: invalid move received!: ${move}`);
					return;
				}
				move_info = new_info(board, move);
				this.table[move] = move_info;
			}

			move_info.version = this.version;

			let tmp;

			tmp = parseInt(InfoVal(s, "N:"), 10);
			if (Number.isNaN(tmp) === false) {
				move_info.n = tmp;
			}

			tmp = parseFloat(InfoVal(s, "(D:"));
			if (Number.isNaN(tmp) === false) {
				move_info.d = tmp;
			}

			tmp = parseFloat(InfoVal(s, "(U:"));
			if (Number.isNaN(tmp) === false) {
				move_info.u = tmp;
			}

			tmp = parseFloat(InfoVal(s, "(Q+U:"));
			if (Number.isNaN(tmp) === false) {
				move_info.q_plus_u = tmp;
			}

			move_info.p = InfoVal(s, "(P:");			// Worst case here is just empty string, which is OK.

			tmp = parseFloat(InfoVal(s, "(Q:"));
			if (Number.isNaN(tmp) === false) {
				this.ever_received_q = true;
				move_info.q = tmp;
			}

			tmp = parseFloat(InfoVal(s, "(V:"));
			if (Number.isNaN(tmp) === false) {
				move_info.v = tmp;
			}
		}
	};

	ih.sorted = function() {

		let info_list = [];

		for (let o of Object.values(this.table)) {
			info_list.push(o);
		}

		info_list.sort((a, b) => {

			// Mate - positive good, negative bad.
			// Note our info struct uses 0 when not given.

			if (Sign(a.mate) !== Sign(b.mate)) {		// negative is worst, 0 is neutral, positive is best
				if (a.mate < b.mate) {
					return 1;
				}
				if (a.mate > b.mate) {
					return -1;
				}
			} else {									// lower (i.e. towards -Inf) is better regardless of who's mating
				if (a.mate < b.mate) {
					return -1;
				}
				if (a.mate > b.mate) {
					return 1;
				}
			} 

			// Node count - higher is better...

			if (a.n < b.n) {
				return 1;
			}
			if (a.n > b.n) {
				return -1;
			}

			// If it's some engine other than Leela, and it isn't respecting MultiPV,
			// that means its most recently sent message should be its best move...

			if (this.ever_received_multipv_2 === false) {
				if (a.version < b.version) {
					return 1;
				}
				if (a.version > b.version) {
					return -1;
				}
			}

			// If we get here, MultiPV is being respected.

			if (a.multipv < b.multipv) {
				return -1;
			}
			if (a.multipv > b.multipv) {
				return 1;
			}

			// We might get here if two moves have the same MultiPV due to one of them
			// being currently turned off with searchmoves. Centipawn score is sometimes
			// unreliable since we might compare an old low depth score with a new high
			// depth score.

			if (a.cp < b.cp) {
				return 1;
			}
			if (a.cp > b.cp) {
				return -1;
			}

			return 0;
		});

		return info_list;
	};

	ih.must_draw_infobox = function() {
		this.last_drawn_version = null;
	};

	ih.draw_statusbox = function(leela_maybe_running, searchmoves) {

		if (config.search_nodes !== "infinite" && (searchmoves.length === 1)) {

			statusbox.innerHTML = `<span class="yellow">Node limit with only 1 focus won't run.</span>`;

		} else {

			let status_string = "";

			if (leela_maybe_running === false) {
				status_string += `<span class="yellow">HALTED - CLICK TO RUN </span>`;
			} else {
				status_string += `<span class="green">RUNNING - CLICK TO STOP </span>`;
			}

			status_string += `<span class="gray">Nodes: ${NString(this.nodes)}, N/s: ${NString(this.nps)}, Time: ${DurationString(this.time)}</span>`;

			if (typeof config.search_nodes === "number" && this.nodes >= config.search_nodes) {
				status_string += ` <span class="blue">(limit exceeded)</span>`;
			}

			statusbox.innerHTML = status_string;
		}
	};

	ih.draw_infobox = function(mouse_point, active_square, leela_maybe_running, active_colour, searchmoves, hoverdraw_div) {

		ih.draw_statusbox(leela_maybe_running, searchmoves);

		// Display stderr and return if we've never seen any info...

		if (!this.ever_received_info) {
			if (this.stderr_log.length > 0) {
				infobox.innerHTML = this.stderr_log;
			}
			return;
		}

		let info_list = this.sorted();

		// We might be highlighting some div...

		let highlight_move = null;
		let highlight_class = null;

		if (mouse_point && mouse_point !== Point(null) && this.one_click_moves[mouse_point.x][mouse_point.y] && !active_square) {
			highlight_move = this.one_click_moves[mouse_point.x][mouse_point.y];
			highlight_class = "ocm_highlight";
		}

		if (typeof hoverdraw_div === "number" && hoverdraw_div >= 0 && hoverdraw_div < info_list.length) {
			highlight_move = info_list[hoverdraw_div].move;
			highlight_class = "hover_highlight";
		}

		// We can skip the draw if:
		//
		// - The last drawn version matches
		// - The last drawn highlight matches
		// - The last drawn highlight class matches
		// - The searchmoves match (some possibility of false negatives due to re-ordering, but that's OK)

		if (this.version === this.last_drawn_version) {
			if (highlight_move === this.last_drawn_highlight_move) {
				if (highlight_class === this.last_drawn_highlight_class) {
					if (CompareArrays(searchmoves, this.last_drawn_searchmoves)) {
						return;
					}
				}
			}
		}

		this.last_drawn_version = this.version;
		this.last_drawn_highlight_move = highlight_move;
		this.last_drawn_highlight_class = highlight_class;
		this.last_drawn_searchmoves = Array.from(searchmoves);

		this.info_clickers = [];

		let substrings = [];
		let clicker_index = 0;
		let div_index = 0;

		for (let info of info_list) {

			// The div containing the PV etc...

			let divclass = "infoline";
			
			if (info.move === highlight_move) {
				divclass += " " + highlight_class;
			}

			substrings.push(`<div id="infoline_${div_index++}" class="${divclass}">`);

			// The "focus" button...

			if (config.searchmoves_buttons) {
				if (ArrayIncludes(searchmoves, info.move)) {
					substrings.push(`<span id="searchmove_${info.move}" class="yellow">focused: </span>`);		// Note: infobox_to_clipboard() expects...
				} else {
					substrings.push(`<span id="searchmove_${info.move}" class="gray">focus? </span>`);			// ...these exact strings.
				}
			}

			// The value...

			let value_string = "?";
			if (config.show_cp) {
				let cp = info.cp;
				if (config.cp_white_pov && active_colour === "b") {
					cp = 0 - cp;
				}
				value_string = (cp / 100).toFixed(2);
				if (cp > 0) {
					value_string = "+" + value_string;
				}
			} else {
				value_string = info.value_string(1) + "%";
			}

			substrings.push(`<span class="blue">${value_string} </span>`);

			// The PV...

			let colour = active_colour;
			let nice_pv = info.nice_pv();

			for (let i = 0; i < nice_pv.length; i++) {
				let spanclass = colour === "w" ? "white" : "pink";
				if (nice_pv[i].includes("O-O")) {
					spanclass += " nobr";
				}
				substrings.push(`<span id="infobox_${clicker_index++}" class="${spanclass}">${nice_pv[i]} </span>`);
				this.info_clickers.push({
					move: info.pv[i],
					is_start: i === 0,
					is_end: i === nice_pv.length - 1,
				});
				colour = OppositeColour(colour);
			}

			// The extra stats...

			let extra_stat_strings = info.stats_list(
				{
					n: config.show_n,
					n_abs: config.show_n_abs,
					p: config.show_p,
					v: config.show_v,
					q: config.show_q,
					d: config.show_d,
					u: config.show_u,
					q_plus_u: config.show_q_plus_u,
				},
				this.nodes);

			if (extra_stat_strings.length > 0) {
				substrings.push(`<span class="gray">(${extra_stat_strings.join(', ')})</span>`);
			}

			// Close the whole div...

			substrings.push("</div>");
			
		}

		infobox.innerHTML = substrings.join("");
	};

	ih.moves_from_click = function(event) {
		let n = EventPathN(event, "infobox_");
		return this.moves_from_click_n(n);
	};

	ih.moves_from_click_n = function(n) {

		if (typeof n !== "number" || Number.isNaN(n)) {
			return [];
		}

		if (!this.info_clickers || n < 0 || n >= this.info_clickers.length) {
			return [];
		}

		let move_list = [];

		// Work backwards until we get to the start of the line...

		for (; n >= 0; n--) {
			let object = this.info_clickers[n];
			move_list.push(object.move);
			if (object.is_start) {
				break;
			}
		}

		move_list.reverse();

		return move_list;
	};

	ih.entire_pv_from_click_n = function(n) {

		let move_list = this.moves_from_click_n(n);		// Does all the sanity checks.

		if (move_list.length === 0) {
			return move_list;
		}

		if (this.info_clickers[n].is_end) {				// Do we already have the whole thing?
			return move_list;
		}

		n++;

		for (; n < this.info_clickers.length; n++) {
			let object = this.info_clickers[n];
			move_list.push(object.move);
			if (object.is_end) {
				break;
			}
		}

		return move_list;
	};

	ih.searchmove_from_click = function(event) {
		let s = EventPathString(event, "searchmove_");
		if (typeof s === "string" && (s.length === 4 || s.length === 5)) {
			return s;
		}
		return null;
	};

	ih.draw_arrows = function() {

		context.lineWidth = config.arrow_width;
		context.textAlign = "center";
		context.textBaseline = "middle";
		context.font = config.board_font;

		let arrows = [];
		let heads = [];

		for (let x = 0; x < 8; x++) {
			for (let y = 0; y < 8; y++) {
				this.one_click_moves[x][y] = null;
			}
		}

		let info_list = this.sorted();

		if (info_list.length > 0) {
			
			for (let i = 0; i < info_list.length; i++) {

				if ((typeof info_list[i].u === "number" && info_list[i].u < config.uncertainty_cutoff) || i === 0) {

					let [x1, y1] = XY(info_list[i].move.slice(0, 2));
					let [x2, y2] = XY(info_list[i].move.slice(2, 4));

					let loss = 0;

					if (typeof info_list[0].q === "number" && typeof info_list[i].q === "number") {
						loss = info_list[0].value() - info_list[i].value();
					}

					let colour;

					if (i === 0) {
						colour = config.best_colour;
					} else if (loss > config.terrible_move_threshold) {
						colour = config.terrible_colour;
					} else if (loss > config.bad_move_threshold) {
						colour = config.bad_colour;
					} else {
						colour = config.good_colour;
					}

					arrows.push({
						colour: colour,
						x1: x1,
						y1: y1,
						x2: x2,
						y2: y2,
						info: info_list[i]
					});

					if (!this.one_click_moves[x2][y2]) {
						this.one_click_moves[x2][y2] = info_list[i].move;
						heads.push({
							colour: colour,
							x2: x2,
							y2: y2,
							info: info_list[i]
						});
					}
				}
			}
		}

		// It looks best if the longest arrows are drawn underneath. Manhattan distance is good enough.
		// For the sake of displaying the best pawn promotion (of the 4 possible), sort ties are broken
		// by node counts, with lower drawn first.

		arrows.sort((a, b) => {
			if (Math.abs(a.x2 - a.x1) + Math.abs(a.y2 - a.y1) < Math.abs(b.x2 - b.x1) + Math.abs(b.y2 - b.y1)) {
				return 1;
			}
			if (Math.abs(a.x2 - a.x1) + Math.abs(a.y2 - a.y1) > Math.abs(b.x2 - b.x1) + Math.abs(b.y2 - b.y1)) {
				return -1;
			}
			if (a.info.n < b.info.n) {
				return -1;
			}
			if (a.info.n > b.info.n) {
				return 1;
			}
			return 0;
		});

		for (let o of arrows) {
			let cc1 = CanvasCoords(o.x1, o.y1);
			let cc2 = CanvasCoords(o.x2, o.y2);
			context.strokeStyle = o.colour;
			context.fillStyle = o.colour;
			context.beginPath();
			context.moveTo(cc1.cx, cc1.cy);
			context.lineTo(cc2.cx, cc2.cy);
			context.stroke();
		}

		for (let o of heads) {
			let cc2 = CanvasCoords(o.x2, o.y2);
			context.fillStyle = o.colour;
			context.beginPath();
			context.arc(cc2.cx, cc2.cy, config.arrowhead_radius, 0, 2 * Math.PI);
			context.fill();
			context.fillStyle = "black";

			let s = "?";

			switch (config.arrowhead_type) {
			case 0:
				s = o.info.value_string(0);
				break;
			case 1:
				if (this.nodes <= 0) {
					s = "?";
					break;
				}
				s = (100 * o.info.n / this.nodes).toFixed(0);
				break;
			case 2:
				let pstr = o.info.p;
				if (pstr.endsWith("%")) {
					pstr = pstr.slice(0, -1);
				}
				let p = parseFloat(pstr);
				if (Number.isNaN(p) === false) {
					s = p.toFixed(0);
				}
				break;
			case 3:
				s = o.info.multipv;
				break;
			default:
				s = "!";
				break;
			}

			context.fillText(s, cc2.cx, cc2.cy + 1);
		}
	};

	return ih;
}

// --------------------------------------------------------------------------------------------

const info_prototype = {

	nice_pv: function() {

		// Human readable moves. Since there's no real guarantee that our
		// moves list is legal, we legality check them.

		if (this.nice_pv_cache) {
			return Array.from(this.nice_pv_cache);
		}

		let tmp_board = this.board;

		if (!this.pv || this.pv.length === 0) {		// Should be impossible.
			this.pv = [this.move];
		}

		let ret = [];

		for (let move of this.pv) {
			if (tmp_board.illegal(move) !== "") {
				break;
			}
			ret.push(tmp_board.nice_string(move));
			tmp_board = tmp_board.move(move);
		}

		this.nice_pv_cache = ret;
		return Array.from(this.nice_pv_cache);
	},

	value: function() {								// Rescale Q to 0..1 range.

		if (typeof this.q !== "number") {
			return 0;
		}

		if (this.q < -1) {
			return 0;
		}

		if (this.q > 1) {
			return 1;
		}

		return (this.q + 1) / 2;
	},

	value_string: function(dp) {
		if (typeof this.q !== "number") {
			return "?";
		}
		return (this.value() * 100).toFixed(dp);
	},

	stats_list: function(opts, nodes_total) {

		let ret = [];

		if (opts.ev) {
			ret.push(`EV: ${this.value_string(1)}%`);
		}

		// N is fairly complicated...

		if (typeof this.n === "number" && nodes_total) {		// i.e. nodes_total is not zero or undefined

			let n_string = "";

			if (opts.n) {
				n_string += ` N: ${(100 * this.n / nodes_total).toFixed(2)}%`;
			}

			if (opts.n_abs) {
				if (opts.n) {
					n_string += ` [${NString(this.n)}]`;
				} else {
					n_string += ` N: ${NString(this.n)}`;
				}
			}

			if (opts.of_n) {
				n_string += ` of ${NString(nodes_total)}`;
			}

			if (n_string !== "") {
				ret.push(n_string.trim());
			}

		} else {

			if (opts.n || opts.n_abs || opts.of_n) {
				ret.push("N: ?");
			}
			
		}

		// Everything else...

		if (opts.p) {
			ret.push(`P: ${this.p}`);
		}

		if (opts.v) {
			if (typeof this.v === "number") {
				ret.push(`V: ${this.v.toFixed(3)}`);
			} else {
				ret.push(`V: ?`);
			}
		}

		if (opts.q) {
			if (typeof this.q === "number") {
				ret.push(`Q: ${this.q.toFixed(3)}`);
			} else {
				ret.push(`Q: ?`);
			}
		}

		if (opts.d) {
			if (typeof this.d === "number") {
				ret.push(`D: ${this.d.toFixed(3)}`);
			} else {
				ret.push(`D: ?`);
			}
		}

		if (opts.u) {
			if (typeof this.u === "number" && this.n > 0) {						// Checking n is correct.
				ret.push(`U: ${this.u.toFixed(3)}`);
			} else {
				ret.push(`U: ?`);
			}
		}

		if (opts.q_plus_u) {
			if (typeof this.q_plus_u === "number" && this.n > 0) {				// Checking n is correct.
				ret.push(`Q+U: ${this.q_plus_u.toFixed(5)}`);
			} else {
				ret.push(`Q+U: ?`);
			}
		}

		return ret;
	}
};

function new_info(board, move) {

	// In some places elsewhere we might assume these things will have sensible values, so
	// better not initialise most things to null. Best to use neutral-ish values, especially
	// since some info (cp and q) can be carried (inverted) into the next step of a line...

	let info = Object.create(info_prototype);
	info.board = board;
	info.cp = 0;
	info.d = 0;
	info.mate = 0;					// 0 can be the "not present" value.
	info.move = move;
	info.multipv = 1;
	info.n = 0;
	info.p = "?";					// Note we receive P as a string, unlike the other stuff.
	info.pv = [move];				// Warning: never assume this is a legal sequence.
	info.nice_pv_cache = null;
	info.q = 0;
	info.q_plus_u = 1;
	info.u = 1;
	info.v = null;					// Warning: v is allowed to be null if not known.
	info.version = 0;
	return info;
}

function NewEngine() {

	let eng = Object.create(null);

	eng.websocket = null;
	eng.readyok_required = 0;
	eng.ever_sent = false;
	eng.warned = false;

	eng.send = function(msg) {
		if (!this.websocket) {
			return;
		}
		this.websocket.send(msg);
	};

	eng.setoption = function(name, value) {
		this.send(`setoption name ${name} value ${value}`);
	};

	// The sync function exists so that we can disregard all output until a certain point.
	// Basically we use it after sending a position, so that we can ignore all analysis
	// that comes until LZ sends "readyok" in response to our "isready". All output before
	// that moment would refer to the obsolete position.
	//
	// Sadly this doesn't always work, because engines - including Lc0 - often send readyok
	// too early, i.e. before they've finished sending info about the position they were
	// just analysing, meaning we have to always assume the info could be about the wrong
	// position. Bah!
	//
	// Observations:
	//
	// Leela seems to send readyok at roughly the correct time if it is after a position
	// command. But not after a mere stop command.

	eng.sync = function() {
		this.send("isready");
		this.readyok_required++;
	};

	eng.setup = function(receive_fn, err_receive_fn) {

		this.receive_fn = receive_fn;
		this.err_receive_fn = err_receive_fn;

		this.websocket = new WebSocket("ws://127.0.0.1:8080");

		this.websocket.addEventListener("message", (event) => {

			// We want to ignore all output when waiting for readyok

			if (event.data.includes("readyok") && this.readyok_required > 0) {
				this.readyok_required--;
			}

			if (this.readyok_required > 0) {
				if (config.log_info_lines || event.data.includes("info") === false) {
					Log("(ignored) < " + event.data);
				}
				return;
			}

			if (config.log_info_lines || event.data.includes("info") === false) {
				Log("< " + event.data);
			}
			this.receive_fn(event.data);
		});
	};
	
	return eng;
}

function NewRenderer() {

	let renderer = Object.create(null);

	renderer.engine = NewEngine();								// Engine connection. Needs its setup() called.
	renderer.node = NewTree();									// Our current place in the current tree.
	renderer.movelist_handler = NewMovelistHander();			// Deals with the movelist at the bottom.

	renderer.info_handler = NewInfoHandler();					// Handles info from the engine, and drawing it.
	renderer.info_handler.clear(renderer.node.get_board());		// Best give it a valid board to start with.

	// Various state we have to keep track of...

	renderer.pgn_choices = null;								// All games found when opening a PGN file.
	renderer.friendly_draws = New2DArray(8, 8);					// What pieces are drawn in boardfriends. Used to skip redraws.
	renderer.active_square = null;								// Clicked square.
	renderer.hoverdraw_div = -1;
	renderer.hoverdraw_depth = 0;
	renderer.tick = 0;											// How many draw loops we've been through.
	renderer.position_change_time = performance.now();			// Time of the last position change. Used for cooldown on hover draw.

	// Some sync stuff...

	renderer.leela_maybe_running = false;						// Whether we last sent "go" or "stop" to Leela.
	renderer.leela_position = null;								// The position we last sent to Leela.
	renderer.searchmoves = [];									// Moves that we're compelling Leela to search.

	// We use both leela_position and the engine.sync() method to ensure that we are actually synced up
	// with Lc0 when interpreting Lc0 output. Neither one on its own is really enough (future me: trust
	// me about this). Indeed I'm not sure if both together are foolproof, which is why we also don't
	// trust moves to be legal.

	// --------------------------------------------------------------------------------------------

	renderer.position_changed = function(new_game_flag) {

		this.position_change_time = performance.now();

		this.searchmoves = [];
		this.hoverdraw_div = -1;
		this.position_changed_clear_info_handler(new_game_flag);
		this.escape();

		this.go_or_halt(new_game_flag);

		this.draw();
		this.movelist_handler.draw(this.node);
		fenbox.value = this.node.get_board().fen();

		if (new_game_flag) {
			document.title = "Nibbler";
			let root = this.node.get_root();
			if (root.tags && root.tags.White && root.tags.White !== "White" && root.tags.Black && root.tags.Black !== "Black") {
				document.title += `: ${root.tags.White} - ${root.tags.Black}`;
			}
		}
	};

	renderer.position_changed_clear_info_handler = function(new_game_flag) {

		// The position has changed. Maybe the new position is contained within a PV
		// of the old info table. We want to clear the info table, but preserving the
		// relevant part of the PV, and evals, if available.

		if (new_game_flag || Object.keys(this.info_handler.table).length === 0) {			// Fail
			this.info_handler.clear(this.node.get_board());
			return;
		}

		if (config.versus === "w" || config.versus === "b") {
			if (this.leela_should_go() === false) {											// Fail (conceal)
				this.info_handler.clear(this.node.get_board());
				return;
			}
		}

		// First, find what ancestor (if any) has the old position...

		let node = this.node;
		let moves = [];
		let found = false;

		while (node.parent) {
			moves.push(node.move);
			if (node.parent.get_board() === this.info_handler.board) {
				found = true;
				break;
			}
			node = node.parent;
		}

		if (found === false) {																// Fail
			this.info_handler.clear(this.node.get_board());
			return;
		}

		moves.reverse();

		// moves is now the sequence of moves that gets us from 
		// the info_handler board to our board.

		let oldinfo = this.info_handler.table[moves[0]];

		if (!oldinfo) {																		// Fail
			this.info_handler.clear(this.node.get_board());
			return;
		}

		if (Array.isArray(oldinfo.pv) === false || oldinfo.pv.length <= moves.length) {		// Fail
			this.info_handler.clear(this.node.get_board());
			return;
		}

		let pv = Array.from(oldinfo.pv);

		// Find out if the oldinfo's PV matches our moves.

		for (let n = 0; n < moves.length; n++) {
			if (pv[n] !== moves[n]) {														// Fail
				this.info_handler.clear(this.node.get_board());
				return;
			}
		}

		// So, everything matches and we can use the PV...

		this.info_handler.clear(this.node.get_board());

		let nextmove = pv[moves.length];
		pv = pv.slice(moves.length);

		this.info_handler.table[nextmove] = new_info(this.node.get_board(), nextmove);
		this.info_handler.table[nextmove].pv = pv;
		this.info_handler.table[nextmove].q = oldinfo.q;
		this.info_handler.table[nextmove].cp = oldinfo.cp;
		this.info_handler.table[nextmove].multipv = 1;

		// Flip our evals if the colour changes...

		if (oldinfo.board.active !== this.node.get_board().active) {
			if (typeof this.info_handler.table[nextmove].q === "number") {
				this.info_handler.table[nextmove].q *= -1;
			}
			if (typeof this.info_handler.table[nextmove].cp === "number") {
				this.info_handler.table[nextmove].cp *= -1;
			}
		}
	};

	renderer.set_versus = function(s) {						// config.versus should not be directly set, call this function instead.
		config.versus = typeof s === "string" ? s : "";
		this.go_or_halt();
	};

	renderer.move = function(s) {							// It is safe to call this with illegal moves.

		if (typeof s !== "string") {
			console.log(`renderer.move(${s}) - bad argument`);
			return;
		}

		let board = this.node.get_board();

		// If a promotion character is required and not present, show the promotion chooser and return
		// without committing to anything.

		if (s.length === 4) {
			let source = Point(s.slice(0, 2));
			if ((board.piece(source) === "P" && source.y === 1) || (board.piece(source) === "p" && source.y === 6)) {
				let illegal_reason = board.illegal(s + "q");
				if (illegal_reason !== "") {
					console.log(`renderer.move(${s}) - ${illegal_reason}`);
				} else {
					this.show_promotiontable(s);
				}
				return;
			}
		}

		// The promised legality check...

		let illegal_reason = board.illegal(s);
		if (illegal_reason !== "") {
			console.log(`renderer.move(${s}) - ${illegal_reason}`);
			return;
		}

		this.node = this.node.make_move(s);
		this.position_changed();
		return;
	};

	renderer.play_info_index = function(n) {
		let info_list = this.info_handler.sorted();
		if (typeof n === "number" && n >= 0 && n < info_list.length) {
			this.move(info_list[n].move);
		}
	};

	renderer.prev = function() {
		if (this.node.parent) {
			this.node = this.node.parent;
			this.position_changed();
		}
	};

	renderer.next = function() {
		if (this.node.children.length > 0) {
			this.node = this.node.children[0];
			this.position_changed();
		}
	};

	renderer.goto_root = function() {
		let root = this.node.get_root();
		if (this.node !== root) {
			this.node = root;
			this.position_changed();
		}
	};

	renderer.goto_end = function() {
		let end = this.node.get_end();
		if (this.node !== end) {
			this.node = end;
			this.position_changed();
		}
	};

	renderer.return_to_main_line = function() {

		let root = this.node.get_root();
		let main_line = root.future_history();
		let history = this.node.history();

		let node = root;

		for (let n = 0; n < history.length; n++) {
			if (main_line[n] !== history[n]) {
				break;
			}
			if (node.children.length === 0) {
				break;
			}
			node = node.children[0];
		}

		if (this.node !== node) {
			this.node = node;
			this.position_changed();
		}
	};

	renderer.promote_to_main_line = function() {
		this.node.promote_to_main_line();
		this.movelist_handler.draw(this.node);
	};

	renderer.delete_node = function() {

		if (!this.node.parent) {
			return;
		}

		let parent = this.node.parent;
		this.node.detach();
		this.node = parent;

		this.position_changed();
	};

	renderer.delete_children = function() {
		for (let child of this.node.children) {
			child.detach();
		}
		this.movelist_handler.draw(this.node);
	};

	renderer.delete_siblings = function() {

		if (!this.node.parent) {
			return;
		}

		for (let sibling of this.node.parent.children) {
			if (sibling !== this.node) {
				sibling.detach();
			}
		}
		
		this.movelist_handler.draw(this.node);
	};

	renderer.load_fen = function(s) {

		if (s.trim() === this.node.get_board().fen()) {
			return;
		}

		let newpos;

		try {
			newpos = LoadFEN(s);
		} catch (err) {
			alert(err);
			return;
		}

		DestroyTree(this.node);			// Optional, but might help the GC.
		this.node = NewTree(newpos);
		this.position_changed(true);
	};

	renderer.new_game = function() {
		DestroyTree(this.node);			// Optional, but might help the GC.
		this.node = NewTree();
		this.position_changed(true);
	};

	renderer.infobox_to_clipboard = function() {
		let s = infobox.innerText;
		s = ReplaceAll(s, "focus? ", "");
		s = ReplaceAll(s, "focused: ", "");
		clipboard.writeText(statusbox.innerText + "\n\n" + s);
	};

	// --------------------------------------------------------------------------------------------
	// PGN...

	renderer.pgn_to_clipboard = function() {
		PGNToClipboard(this.node);
	};

	renderer.save = function(filename) {
		SavePGN(filename, this.node);
	};

	renderer.open = function(filename) {
		let buf = fs.readFileSync(filename);
		this.load_pgn_buffer(buf);
	};

	renderer.load_pgn_from_string = function(s) {
		let buf = Buffer.from(s);
		this.load_pgn_buffer(buf);
	};

	renderer.load_pgn_buffer = function(buf) {

		let new_pgn_choices = PreParsePGN(buf);

		if (new_pgn_choices.length === 1) {
			let success = this.load_pgn_object(new_pgn_choices[0]);
			if (success) {
				this.pgn_choices = new_pgn_choices;			// We only want to set this to a 1 value array if it actually worked.
			}
		} else {
			this.pgn_choices = new_pgn_choices;				// Setting it to a multi-value array is "always" OK.
			this.show_pgn_chooser();						// Now we need to have the user choose a game.
		}
	};

	renderer.load_pgn_object = function(o) {				// Returns true or false - whether this actually succeeded.

		let new_root;

		try {
			new_root = LoadPGNRecord(o);
		} catch (err) {
			alert(err);
			return false;
		}

		DestroyTree(this.node);								// Optional, but might help the GC.
		this.node = new_root;
		this.position_changed(true);

		return true;
	};

	renderer.show_pgn_chooser = function() {

		if (!this.pgn_choices) {
			alert("No PGN loaded");
			return;
		}

		this.hide_promotiontable();		// Just in case it's up.
		this.set_versus("");			// It's lame to run the GPU when we're clearly switching games.

		let lines = [];

		let max_ordinal_length = this.pgn_choices.length.toString().length;
		let padding = "";
		for (let n = 0; n < max_ordinal_length - 1; n++) {
			padding += "&nbsp;";
		}

		for (let n = 0; n < this.pgn_choices.length; n++) {

			if (n === 9 || n === 99 || n === 999 || n === 9999 || n === 99999 || n === 999999) {
				padding = padding.slice(0, -6);
			}

			let p = this.pgn_choices[n];

			let s;

			if (p.tags.Result === "1-0") {
				s = `${padding}${n + 1}. <span class="blue">${p.tags.White}</span> - ${p.tags.Black}`;
			} else if (p.tags.Result === "0-1") {
				s = `${padding}${n + 1}. ${p.tags.White} - <span class="blue">${p.tags.Black}</span>`;
			} else {
				s = `${padding}${n + 1}. ${p.tags.White} - ${p.tags.Black}`;
			}

			if (p.tags.Opening) {
				s += `  <span class="gray">(${p.tags.Opening})</span>`;
			}

			lines.push(`<li id="chooser_${n}">${s}</li>`);
		}

		pgnchooser.innerHTML = "<ul>" + lines.join("") + "</ul>";
		pgnchooser.style.display = "block";
	};

	renderer.hide_pgn_chooser = function() {
		pgnchooser.style.display = "none";
	};

	renderer.pgnchooser_click = function(event) {
		let n = EventPathN(event, "chooser_");
		if (typeof n !== "number") {
			return;
		}
		if (this.pgn_choices && n >= 0 && n < this.pgn_choices.length) {
			this.load_pgn_object(this.pgn_choices[n]);
		}
	};

	renderer.validate_pgn = function(filename) {
		let buf = fs.readFileSync(filename);		// i.e. binary buffer object
		let pgn_list = PreParsePGN(buf);

		for (let n = 0; n < pgn_list.length; n++) {

			let o = pgn_list[n];

			try {
				LoadPGNRecord(o);
			} catch (err) {
				alert(`Game ${n + 1} - ${err.toString()}`);
				return false;
			}
		}

		alert(`This file seems OK. ${pgn_list.length} ${pgn_list.length === 1 ? "game" : "games"} checked.`);
		return true;
	};

	// --------------------------------------------------------------------------------------------
	// Engine stuff...

	renderer.leela_should_go = function() {
		return config.versus.includes(this.node.get_board().active);
	};

	renderer.receive = function(s) {
		if (s.startsWith("info")) {
			if (this.leela_position === this.node.get_board()) {		// Note leela_position is a misleading name - it's the last position we
				this.info_handler.receive(s, this.node.get_board());	// sent, but Leela could be sending info about the previous position.
			}															// So the above condition doesn't prove the info is current.
		}
		if (s.startsWith("error")) {
			this.info_handler.err_receive(s);
		}
		if (s.startsWith("id name")) {
			for (let n = 10; n < 21; n++) {
				if (s.includes(`v0.${n}`)) {
					this.info_handler.err_receive(`<span class="blue">Nibbler says: this version of Lc0 may be too old to display most statistics.</span>`);
				}
			}
		}
	};

	renderer.err_receive = function(s) {
		this.info_handler.err_receive(s);
	};

	// The go and halt methods should generally not be called directly.

	renderer.go_or_halt = function(new_game_flag) {
		if (this.leela_should_go()) {
			this.__go(new_game_flag);								
		} else {
			this.__halt(new_game_flag);
		}
	};

	renderer.__halt = function(new_game_flag) {		// engine.sync() is not needed. If changing position, invalid data will be discarded by renderer.receive().
		if (this.leela_maybe_running) {
			this.engine.send("stop");		
			this.leela_maybe_running = false;
		}
		if (new_game_flag) {
			this.engine.send("ucinewgame");
		}
	};

	renderer.__go = function(new_game_flag) {

		this.validate_searchmoves();				// Leela can crash on illegal searchmoves.
		this.hide_pgn_chooser();

		if (this.leela_maybe_running) {
			this.engine.send("stop");
		}

		if (new_game_flag) {
			this.engine.send("ucinewgame");
		}

		let start_fen = this.node.get_root().get_board().fen();

		let setup;
		if (start_fen === "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1") {
			setup = "startpos";
		} else {
			setup = `fen ${start_fen}`;
		}

		this.engine.send(`position ${setup} moves ${this.node.history().join(" ")}`);
		this.engine.sync();			// Disregard Leela output until "readyok" comes. Leela seems to time "readyok" correctly after "position" commands.

		let s;

		if (typeof config.search_nodes !== "number") {
			s = "go infinite";
		} else {
			s = `go nodes ${config.search_nodes}`;
		}

		if (this.searchmoves.length > 0) {
			s += " searchmoves";
			for (let move of this.searchmoves) {
				s += " " + move;
			}
		}

		this.engine.send(s);

		this.leela_maybe_running = true;
		this.leela_position = this.node.get_board();
	};

	renderer.validate_searchmoves = function() {

		if (!config.searchmoves_buttons) {
			this.searchmoves = [];
			return;
		}

		let valid_list = [];
		let board = this.node.get_board();

		for (let move of this.searchmoves) {
			if (board.illegal(move) === "") {
				valid_list.push(move);
			}
		}

		this.searchmoves = valid_list;
	};

	renderer.reset_leela_cache = function() {
		if (this.leela_should_go()) {
			this.__go(true);
		} else {
			this.engine.send("ucinewgame");
		}
	};

	renderer.switch_weights = function(filename) {
		this.set_versus("");
		this.engine.setoption("WeightsFile", filename);
	};

	// --------------------------------------------------------------------------------------------
	// Settings etc...

	renderer.toggle = function(option) {

		// Cases with their own handler...

		if (option === "flip") {
			this.toggle_flip();
			return;
		}

		// Normal cases...

		config[option] = !config[option];
		this.info_handler.must_draw_infobox();

		// Cases that have additional actions after...

		if (option === "searchmoves_buttons") {
			if (!config.searchmoves_buttons) {		// We turned it off.
				this.searchmoves = [];
				this.go_or_halt();
			}
		}
	};

	renderer.toggle_flip = function() {				// config.flip should not be directly set, call this function instead.

		config.flip = !config.flip;

		for (let x = 0; x < 8; x++) {
			for (let y = 0; y < 4; y++) {

				let first = document.getElementById(`overlay_${S(x, y)}`);
				let second = document.getElementById(`overlay_${S(7 - x, 7 - y)}`);
				SwapElements(first, second);

				first = document.getElementById(`underlay_${S(x, y)}`);
				second = document.getElementById(`underlay_${S(7 - x, 7 - y)}`);
				SwapElements(first, second);
			}
		}

		this.draw();								// For the canvas stuff.
	};

	renderer.invert_searchmoves = function() {

		if (!config.searchmoves_buttons) {
			return;
		}

		// It's no disaster if the result is wrong somehow, because
		// searchmoves are validated before being sent to Leela.

		let moveset = Object.create(null);

		for (let move of Object.keys(this.info_handler.table)) {
			moveset[move] = true;
		}

		for (let move of this.searchmoves) {
			delete moveset[move];
		}

		this.searchmoves = Object.keys(moveset);
		this.go_or_halt();
	};

	renderer.clear_searchmoves = function() {
		this.searchmoves = [];
		this.go_or_halt();
	};

	renderer.set_cpuct = function(val) {
		this.__halt();
		this.engine.setoption("CPuct", val);
		this.go_or_halt();
	};

	renderer.escape = function() {					// Set things into a clean state.
		this.hide_pgn_chooser();
		this.hide_promotiontable();
		this.set_active_square(null);
	};

	renderer.toggle_debug_css = function() {
		let ss = document.styleSheets[0];
		let i = 0;
		for (let rule of Object.values(ss.cssRules)) {
			if (rule.selectorText && rule.selectorText === "*") {
				ss.deleteRule(i);
				return;
			}
			i++;
		}
		ss.insertRule("* {outline: 1px dotted red;}");
	};

	renderer.console = function(...args) {
		console.log(...args);
	};

	renderer.save_config = function(filename) {
		let copy = JSON.parse(JSON.stringify(config));
		for (let key of Object.keys(copy)) {
			if (config_loader.defaults[key] === undefined) {
				delete copy[key];
			}
		}
		fs.writeFileSync(filename, JSON.stringify(copy, null, "\t"));
	};

	renderer.fire_gc = function() {

		if (!global || !global.gc) {
			alert("Unable.");
			return;
		}

		alert("Firing GC in 5 seconds.");
		setTimeout(global.gc, 5000);
	};

	// --------------------------------------------------------------------------------------------
	// Clicks, drops, mouse stuff...

	renderer.set_active_square = function(new_point) {

		// We do things this way so it's snappy and responsive. We could do it
		// in the canvas instead, but then we'd need a whole canvas redraw
		// every time it changes (or accept the lag). Meh.

		let old_point = this.active_square;

		if (old_point && old_point !== Point(null)) {
			let td = document.getElementById("underlay_" + old_point.s);
			td.style["background-color"] = (old_point.x + old_point.y) % 2 === 0 ? config.light_square : config.dark_square;
		}

		this.active_square = null;

		if (new_point && new_point !== Point(null)) {
			let td = document.getElementById("underlay_" + new_point.s);
			td.style["background-color"] = config.active_square;
			this.active_square = new_point;
		}
	};

	renderer.boardfriends_click = function(event) {

		let s = EventPathString(event, "overlay_");
		let p = Point(s);
		
		if (p === Point(null)) {
			return;
		}

		this.hide_promotiontable();						// Just in case it's up.

		let ocm = this.info_handler.one_click_moves[p.x][p.y];
		let board = this.node.get_board();

		if (!this.active_square && ocm) {
			this.set_active_square(null);
			this.move(ocm);
			return;
		}

		if (this.active_square) {
			let move = this.active_square.s + p.s;		// e.g. "e2e4" - note promotion char is handled by renderer.move()
			this.set_active_square(null);
			this.move(move);
			return;
		}

		if (board.active === "w" && board.is_white(p)) {
			this.set_active_square(p);
		}
		if (board.active === "b" && board.is_black(p)) {
			this.set_active_square(p);
		}
	};

	renderer.infobox_click = function(event) {

		let moves = this.info_handler.moves_from_click(event);

		if (!moves || moves.length === 0) {				// We do assume length > 0 below.
			this.maybe_searchmove_click(event);
			return;
		}

		let illegal_reason = this.node.get_board().sequence_illegal(moves);
		if (illegal_reason !== "") {
			console.log("infobox_click(): " + illegal_reason);
			return;
		}

		// Add the moves to the tree...

		let node = this.node;
		for (let move of moves) {
			node = node.make_move(move);
		}

		// Maybe we're done...

		if (!config.serious_analysis_mode) {
			this.node = node;
			this.position_changed();
			return;
		}

		// OK, so we're in Serious Analysis Mode (tm). We don't change this.node.
		// But we do save some statistics into the node of the first move made...

		let stats_node = this.node.make_move(moves[0]);
		let info = this.info_handler.table[moves[0]];		// info for the first move in our clicked line.

		if (info) {

			let sl = info.stats_list(
				{
					ev: config.sam_ev,
					n: config.sam_n,
					n_abs: config.sam_n_abs,
					of_n: config.sam_of_n,
					p: config.sam_p,
					v: config.sam_v,
					q: config.sam_q,
					d: config.sam_d,
					u: config.sam_u,
					q_plus_u: config.sam_q_plus_u,
				},
				this.info_handler.nodes);

			if (sl.length > 0) {
				stats_node.stats = sl.join(", ");
			}
		}

		this.movelist_handler.draw(this.node);				// Draw the tree with the current node (this.node) as highlight.
		this.movelist_handler.redraw_node(stats_node);		// Redraw the stats node, which might not have been drawn (if draw was lazy).
	};

	renderer.maybe_searchmove_click = function(event) {

		let sm = this.info_handler.searchmove_from_click(event);

		if (!sm) {
			return;
		}

		if (ArrayIncludes(this.searchmoves, sm)) {
			this.searchmoves = this.searchmoves.filter(move => move !== sm);
		} else {
			this.searchmoves.push(sm);
		}

		this.go_or_halt();									// If we're running, send a new go message with the updated searchmoves.
	};

	renderer.movelist_click = function(event) {

		let node = this.movelist_handler.node_from_click(event);

		if (!node || node.get_root() !== this.node.get_root()) {
			return;
		}

		if (node !== this.node) {
			this.node = node;
			this.position_changed();
		}
	};

	renderer.show_promotiontable = function(partial_move) {

		promotiontable.innerHTML = "";

		let tr = document.createElement("tr");
		promotiontable.appendChild(tr);

		let pieces = "QRBN";

		if (this.node.get_board().active === "b") {
			pieces = "qrbn";
		}

		for (let piece of Array.from(pieces)) {

			let td = document.createElement("td");
			td.width = config.square_size;
			td.height = config.square_size;
			td.style["background-image"] = "url('" + images[piece].src + "')";
			td.style["background-size"] = "contain";

			// This isn't a memory leak is it? The handlers are deleted when the element is deleted, right?

			td.addEventListener("mousedown", () => {
				this.hide_promotiontable();
				this.move(partial_move + piece.toLowerCase());
			});

			tr.appendChild(td);
		}

		promotiontable.style.display = "block";
	};

	renderer.hide_promotiontable = function() {
		promotiontable.style.display = "none";
	};

	renderer.handle_drop = function(event) {

		// Note to self - examining the event in the console can be misleading
		// because the object seems to get changed after it's finished firing
		// or something.

		// Just about any drop should clear the active square...

		this.set_active_square(null);
/*
		// Is it a file?

		if (event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files[0] && event.dataTransfer.files[0].path) {
			this.open(event.dataTransfer.files[0].path);
			return;
		}
*/
		// Is it a piece?

		let text_data = event.dataTransfer.getData("text");
		if (text_data.startsWith("overlay_")) {

			let source = Point(text_data.slice(8, 10));
			let dest = Point(null);

			let path = event.path || (event.composedPath && event.composedPath());

			if (path) {
				for (let item of path) {
					if (typeof item.id === "string" && item.id.startsWith("overlay_")) {
						dest = Point(item.id.slice(8, 10));
						break;
					}
				}
			}

			if (source !== Point(null) && dest !== Point(null)) {
				this.move(source.s + dest.s);
			}

			return;
		}
	};

	renderer.mouse_point = function() {
		let overlist = document.querySelectorAll(":hover");
		for (let item of overlist) {
			if (typeof item.id === "string" && item.id.startsWith("overlay_")) {
				let p = Point(item.id.slice(8));
				if (p !== Point(null)) {
					return p;
				} else {
					return null;
				}
			}
		}
		return null;
	};

	// --------------------------------------------------------------------------------------------
	// General draw code...

	renderer.draw_friendlies_in_table = function() {

		let position = this.node.get_board();

		for (let x = 0; x < 8; x++) {
			for (let y = 0; y < 8; y++) {

				let piece_to_draw = "";

				if (position.colour(Point(x, y)) === position.active) {
					piece_to_draw = position.state[x][y];
				}

				if (piece_to_draw === this.friendly_draws[x][y]) {
					continue;
				}

				// So if we get to here, we need to draw...

				this.friendly_draws[x][y] = piece_to_draw;

				let s = S(x, y);
				let td = document.getElementById("overlay_" + s);

				if (piece_to_draw === "") {
					td.style["background-image"] = "none";
					td.draggable = false;
				} else {
					td.style["background-image"] = "url('" + images[piece_to_draw].src + "')";
					td.style["background-size"] = "contain";
					td.draggable = true;
				}
			}
		}
	};

	renderer.draw_move_in_canvas = function() {

		if (typeof config.move_colour_alpha !== "number" || config.move_colour_alpha <= 0) {
			return;
		}

		let move = this.node.move;

		if (typeof move !== "string") {
			return;
		}

		let source = Point(move.slice(0, 2));
		let dest = Point(move.slice(2, 4));

		if (!source || source === Point(null) || !dest || dest === Point(null)) {
			return;
		}

		context.fillStyle = config.move_colour;
		context.globalAlpha = config.move_colour_alpha;

		let cc = CanvasCoords(source.x, source.y);
		context.fillRect(cc.x1, cc.y1, config.square_size, config.square_size);

		cc = CanvasCoords(dest.x, dest.y);
		context.fillRect(cc.x1, cc.y1, config.square_size, config.square_size);

		context.globalAlpha = 1;
	};

	renderer.draw_enemies_in_canvas = function() {

		let board = this.node.get_board();

		for (let x = 0; x < 8; x++) {
			for (let y = 0; y < 8; y++) {

				if (board.state[x][y] === "" || board.colour(Point(x, y)) === board.active) {
					continue;
				}

				let piece = board.state[x][y];
				let cc = CanvasCoords(x, y);
				context.drawImage(images[piece], cc.x1, cc.y1, config.square_size, config.square_size);
			}
		}
	};

	renderer.hoverdraw = function() {

		if (!config.hover_draw) {
			return false;
		}

		if (performance.now() - this.position_change_time < 1000) {
			return false;
		}

		let overlist = document.querySelectorAll(":hover");

		let div_index = null;

		for (let item of overlist) {
			if (typeof item.id === "string" && item.id.startsWith("infoline_")) {
				div_index = parseInt(item.id.slice("infoline_".length), 10);
				break;
			}
		}

		if (typeof div_index !== "number" || Number.isNaN(div_index)) {
			return false;
		}

		let info = this.info_handler.sorted()[div_index];			// Possibly undefined

		if (!info || Array.isArray(info.pv) === false || info.pv.length === 0) {
			return false;
		}

		if (config.hover_method === 0) {
			return this.hoverdraw_animate(div_index, info);			// Sets this.hoverdraw_div
		} else if (config.hover_method === 1) {
			return this.hoverdraw_single(div_index, overlist);		// Sets this.hoverdraw_div
		} else {
			return false;											// Caller must set this.hoverdraw_div to -1
		}
	};

	renderer.hoverdraw_animate = function(div_index, info) {

		// If the user is hovering over an unexpected div index in the infobox, reset depth...

		if (div_index !== this.hoverdraw_div) {
			this.hoverdraw_div = div_index;
			this.hoverdraw_depth = 0;
		}

		// Sometimes increase depth...

		if (this.tick % config.animate_delay_multiplier === 0) {
			this.hoverdraw_depth++;
		}

		return this.draw_fantasy_from_moves(info.pv.slice(0, this.hoverdraw_depth));	// Relies on slice() being safe if depth > length
	};

	renderer.hoverdraw_single = function(div_index, overlist) {

		this.hoverdraw_div = div_index;

		let hover_item = null;

		for (let item of overlist) {
			if (typeof item.id === "string" && item.id.startsWith("infobox_")) {
				hover_item = item;
				break;
			}
		}

		if (!hover_item) {
			return false;
		}

		let moves = this.info_handler.moves_from_click_n(parseInt(hover_item.id.slice("infobox_".length), 10));

		if (Array.isArray(moves) === false || moves.length === 0) {
			return false;
		}

		return this.draw_fantasy_from_moves(moves);
	};

	renderer.draw_fantasy_from_moves = function(moves) {

		// Don't assume moves is an array of legal moves, or even an array.

		if (Array.isArray(moves) === false) {
			return false;
		}

		let board = this.node.get_board();

		for (let move of moves) {
			let illegal_reason = board.illegal(move);
			if (illegal_reason !== "") {
				return false;
			}
			board = board.move(move);
		}

		this.draw_fantasy(board);
		return true;
	};

	renderer.draw_fantasy = function(board) {

		let ctx = fantasy.getContext("2d");

		for (let x = 0; x < 8; x++) {
			for (let y = 0; y < 8; y++) {

				ctx.fillStyle = (x + y) % 2 === 0 ? config.light_square : config.dark_square;

				let cc = CanvasCoords(x, y);
				ctx.fillRect(cc.x1, cc.y1, config.square_size, config.square_size);

				if (board.state[x][y] === "") {
					continue;
				}

				let piece = board.state[x][y];
				ctx.drawImage(images[piece], cc.x1, cc.y1, config.square_size, config.square_size);
			}
		}
	};

	renderer.draw = function() {

		debug.draw = true;

		// We do the :hover reaction first. This way, we are detecting hover based on the previous cycle's state.
		// This should prevent the sort of flicker that can occur if we try to detect hover based on changes we
		// just made (i.e. if we drew then detected hover instantly).

		let did_hoverdraw = this.hoverdraw();

		if (did_hoverdraw) {
			fantasy.style.display = "block";
		} else {
			this.hoverdraw_div = -1;
			fantasy.style.display = "none";
			context.clearRect(0, 0, canvas.width, canvas.height);
			this.draw_move_in_canvas();
			this.draw_enemies_in_canvas();
			this.info_handler.draw_arrows();
			this.draw_friendlies_in_table();
		}

		this.info_handler.draw_infobox(		// The info handler needs a bit more state than I'd like, but what can you do.
			this.mouse_point(),
			this.active_square,
			this.leela_maybe_running,
			this.node.get_board().active,
			this.searchmoves,
			this.hoverdraw_div);

		debug.draw = false;
	};

	renderer.draw_loop = function() {
		this.tick++;
		this.draw();
		setTimeout(this.draw_loop.bind(this), config.update_delay);
	};

	// --------------------------------------------------------------------------------------------
	// The call to setup needs to happen after renderer.receive and .err_receive actually exist...

	renderer.engine.setup(renderer.receive.bind(renderer), renderer.err_receive.bind(renderer));

	renderer.engine.websocket.addEventListener("open", (event) => {
		renderer.set_versus("wb");
	}, {once: true});

	fenbox.value = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

	return renderer;
}

Log("");
Log("======================================================================================================================================");
Log(`Nibbler startup at ${new Date().toUTCString()}`);
Log("");

let hub = NewRenderer();

// We have 3 main things that get drawn to:
//
//		- boardsquares, a table with the actual squares of the board.
//		- canvas, which gets enemy pieces and arrows drawn on it.
//		- boardfriends, a table with friendly pieces.
//
// boardsquares has its natural position, while the other two get
// fixed position that is set to be on top of it.

boardfriends.width = canvas.width = fantasy.width = boardsquares.width = config.board_size;
boardfriends.height = canvas.height = fantasy.height = boardsquares.height = config.board_size;

boardfriends.style.left = canvas.style.left = fantasy.style.left = boardsquares.offsetLeft.toString() + "px";
boardfriends.style.top = canvas.style.top = fantasy.style.top = boardsquares.offsetTop.toString() + "px";

// Set up the squares in both tables. Note that, upon flips, the elements
// themselves are moved to their new position, so everything works, e.g.
// the x and y values are still correct for the flipped view.

for (let y = 0; y < 8; y++) {
	let tr1 = document.createElement("tr");
	let tr2 = document.createElement("tr");
	boardsquares.appendChild(tr1);
	boardfriends.appendChild(tr2);
	for (let x = 0; x < 8; x++) {
		let td1 = document.createElement("td");
		let td2 = document.createElement("td");
		td1.id = "underlay_" + S(x, y);
		td2.id = "overlay_" + S(x, y);
		td1.width = td2.width = config.square_size;
		td1.height = td2.height = config.square_size;
		if ((x + y) % 2 === 0) {
			td1.style["background-color"] = config.light_square;
		} else {
			td1.style["background-color"] = config.dark_square;
		}
		tr1.appendChild(td1);
		tr2.appendChild(td2);
		td2.addEventListener("dragstart", (event) => {
			hub.set_active_square(Point(x, y));
			event.dataTransfer.setData("text", "overlay_" + S(x, y));
		});
	}
}

// Font sizes... do this before calculating sizes of stuff below.

infobox.style["font-size"] = config.info_font_size.toString() + "px";
movelist.style["font-size"] = config.pgn_font_size.toString() + "px";
fenbox.style["font-size"] = config.fen_font_size.toString() + "px";
statusbox.style["font-size"] = config.status_font_size.toString() + "px";

// We rely on the statusbox having some text when doing these calculations,
// so that the infobox_top has its final position.

let infobox_top = infobox.getBoundingClientRect().top;
let canvas_bottom = canvas.getBoundingClientRect().bottom;

infobox.style.height = (canvas_bottom - infobox_top).toString() + "px";

// The promotion table pops up when needed...

promotiontable.style.left = (boardsquares.offsetLeft + config.square_size * 2).toString() + "px";
promotiontable.style.top = (boardsquares.offsetTop + config.square_size * 3.5).toString() + "px";
promotiontable.style["background-color"] = config.active_square;

// --------------------------------------------------------------------------------------------
// In bad cases of super-large trees, the UI can become unresponsive. To mitigate this, we
// put user input in a queue, and drop things if they build up.

let input_queue = [];
let total_dropped_inputs = 0;

// The queue needs to be examined very regularly and acted upon.

function input_loop() {

	debug.input_loop = true;

	let fn;

	let length = input_queue.length;

	if (length === 1) {
		fn = input_queue[0];
	} else if (length > 1) {
		total_dropped_inputs += length - 1;
		console.log(`input_loop() dropped ${length - 1} input${length === 2 ? "" : "s"}, total now ${total_dropped_inputs}.`);
		fn = input_queue[length - 1];
	}

	input_queue = [];

	if (fn) {
		fn();
	}

	setTimeout(input_loop, 10);
	debug.input_loop = false;
}

input_loop();

// --------------------------------------------------------------------------------------------
// We had some problems with the various clickers: we used to destroy and create
// clickable objects a lot. This seemed to lead to moments where clicks wouldn't
// register.
//
// A better approach is to use event handlers on the outer elements, and examine
// the event.path to see what was actually clicked on.

pgnchooser.addEventListener("mousedown", (event) => {
	hub.pgnchooser_click(event);
});

boardfriends.addEventListener("mousedown", (event) => {
	hub.boardfriends_click(event);
});

infobox.addEventListener("mousedown", (event) => {
	hub.infobox_click(event);
});

movelist.addEventListener("mousedown", (event) => {
	hub.movelist_click(event);
});

statusbox.addEventListener("mousedown", (event) => {
	if (config.versus === "") {
		hub.set_versus("wb");
	} else {
		hub.set_versus("");
	}
});

document.addEventListener("wheel", (event) => {

	// Only if the PGN chooser is closed, and the mouse is over the board.

	if (pgnchooser.style.display !== "none") {
		return;
	}

	let allow = false;

	let path = event.path || (event.composedPath && event.composedPath());

	if (path) {
		for (let item of path) {
			if (item.id === "boardfriends") {
				allow = true;
				break;
			}
		}
	}

	if (allow) {
		if (event.deltaY && event.deltaY < 0) input_queue.push(hub.prev.bind(hub));
		if (event.deltaY && event.deltaY > 0) input_queue.push(hub.next.bind(hub));
	}
});

// Setup return key on FEN box...

fenbox.addEventListener("keydown", (event) => {
	if (event.key === "Enter") {
		hub.load_fen(fenbox.value);
	}
});

// Setup drag-and-drop...

window.addEventListener("dragenter", (event) => {		// Necessary to prevent brief flashes of "not allowed" icon.
	event.preventDefault();
});

window.addEventListener("dragover", (event) => {		// Necessary to prevent always having the "not allowed" icon.
	event.preventDefault();
});

window.addEventListener("drop", (event) => {
	event.preventDefault();
	hub.handle_drop(event);
});

// Debug. Various functions set a key in the debug object when they start, and clear it when they return.
// So if we ever find such a key with a non-false value, it means a function failed to return.

function debug_loop() {
	for (let key of Object.keys(debug)) {
		if (debug[key]) {
			alert(
`There may have been an uncaught exception. If you could open the dev tools and the console tab \
therein, and report the contents to the author (ideally with a screenshot) that would be grand.`);
			return;		// Return before setTimeout, thus no more warnings.
		}
	}
	setTimeout(debug_loop, 5000);
}

debug_loop();

// Go...

hub.draw_loop();
